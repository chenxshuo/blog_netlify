<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="*此文用于供大家自己提前预习 以及课堂内容的补充* 本笔记的知识点大多搬运《Java核心技术 卷I》和《Java程序设计基础(第五版)  陈国君 编》 在正式开课之前，学习环境如下:  操作系统: Arch Linux JDK: Oracle JDK IDE: Eclipse 文本编辑器: VS Code  第一章 Java语言概述1.1 Java语言的特点1.1.1 简单性 Java语言衍生自C">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Learn by yourself by 倾启君">
<meta property="og:url" content="https://chenxshuo.cn/2017/09/08/Java-Learn-Book/index.html">
<meta property="og:site_name" content="chenxshuo">
<meta property="og:description" content="*此文用于供大家自己提前预习 以及课堂内容的补充* 本笔记的知识点大多搬运《Java核心技术 卷I》和《Java程序设计基础(第五版)  陈国君 编》 在正式开课之前，学习环境如下:  操作系统: Arch Linux JDK: Oracle JDK IDE: Eclipse 文本编辑器: VS Code  第一章 Java语言概述1.1 Java语言的特点1.1.1 简单性 Java语言衍生自C">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-05T07:29:54.894Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Learn by yourself by 倾启君">
<meta name="twitter:description" content="*此文用于供大家自己提前预习 以及课堂内容的补充* 本笔记的知识点大多搬运《Java核心技术 卷I》和《Java程序设计基础(第五版)  陈国君 编》 在正式开课之前，学习环境如下:  操作系统: Arch Linux JDK: Oracle JDK IDE: Eclipse 文本编辑器: VS Code  第一章 Java语言概述1.1 Java语言的特点1.1.1 简单性 Java语言衍生自C">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://chenxshuo.cn/2017/09/08/Java-Learn-Book/">





  <title>Java Learn by yourself by 倾启君 | chenxshuo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">chenxshuo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://chenxshuo.cn/2017/09/08/Java-Learn-Book/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenshuo">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="chenxshuo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java Learn by yourself by 倾启君</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-08T19:52:46+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>*<u>此文用于供大家自己提前预习 以及课堂内容的补充</u>*</p>
<p>本笔记的知识点大多搬运《Java核心技术 卷I》和《Java程序设计基础(第五版)  陈国君 编》</p>
<p>在正式开课之前，学习环境如下:</p>
<ul>
<li>操作系统: Arch Linux</li>
<li>JDK: Oracle JDK</li>
<li>IDE: Eclipse</li>
<li>文本编辑器: VS Code</li>
</ul>
<h1 id="第一章-Java语言概述"><a href="#第一章-Java语言概述" class="headerlink" title="第一章 Java语言概述"></a>第一章 Java语言概述</h1><h2 id="1-1-Java语言的特点"><a href="#1-1-Java语言的特点" class="headerlink" title="1.1 Java语言的特点"></a>1.1 Java语言的特点</h2><h3 id="1-1-1-简单性"><a href="#1-1-1-简单性" class="headerlink" title="1.1.1 简单性"></a>1.1.1 简单性</h3><ul>
<li>Java语言衍生自C++，与C++相比Java是一门完全面向对象的编程语言。</li>
<li>Java去掉了C++中许多很少使用、难以理解、易混淆的特性。使之更加合理规范，并且降低了学习难度</li>
</ul>
<h3 id="1-1-2-面向对象"><a href="#1-1-2-面向对象" class="headerlink" title="1.1.2 面向对象"></a>1.1.2 面向对象</h3><ul>
<li>面向对象设计(OOP)是一种程序设计技术，它将重点放在数据(即对象)和对象的接口上。</li>
<li>面向对象的语言都支持三个概念：<ul>
<li>封装<br>利用抽象数据类型将数据和基于数据的操作封装在一起，数据被保护在抽象数据类型的内部，系统的其他部分只能通过封装在数据外面的被授权的操作才能够于这个抽象数据类型交互。</li>
<li>继承<br>继承指一个对象直接使用另一个对象的属性和方法。与C++不同，Java主要通过接口来实现多重继承。</li>
<li>多态<br>多态是指一个程序中同名的多个不同方法共存的情况，即一个对外接口，多个内部实现方法。</li>
</ul>
</li>
</ul>
<h3 id="1-1-3-分布式"><a href="#1-1-3-分布式" class="headerlink" title="1.1.3 分布式"></a>1.1.3 分布式</h3><ul>
<li>分布式包括数据分布和操作分布<ul>
<li>数据分布：数据可以分散在网络的不同主机上。</li>
<li>操作分布：一个计算分散在不同的主机上处理。</li>
</ul>
</li>
</ul>
<ol>
<li>Java提供了一整套网络类库，方便开发人员进行网络程序设计，方便实现分布式特性。</li>
<li>对于数据分布，Java应用程序可以通过URL打开和访问网络上的对象，访问方式与访问本地文件系统相同。</li>
<li>对于操作分布，Java的小程序(Applet)可以从服务器下载到客户端，将部分计算在客户端进行，提高系统执行效率。</li>
</ol>
<h3 id="1-1-4-可靠性"><a href="#1-1-4-可靠性" class="headerlink" title="1.1.4 可靠性"></a>1.1.4 可靠性</h3><ol>
<li>Java语言是强类型的语言，要求用显式的方法说明，保证了编译器可以发现方法的调用错误。</li>
<li>Java语言不支持指针，避免了对内存的非法访问。</li>
<li>Java的自动单元回收功能防止了内存丢失等动态内存分配导致的问题。</li>
<li>Java解释器运行时实施检查。</li>
<li>Java语言提供了异常处理机制，可以简化错误处理任务。</li>
<li>Java编译器能够检测许多在其他语言中仅运行时才能检测出来的问题。</li>
</ol>
<h3 id="1-1-5-安全性"><a href="#1-1-5-安全性" class="headerlink" title="1.1.5 安全性"></a>1.1.5 安全性</h3><p>安全机制:</p>
<ol>
<li>当Java字节码进入解释器时，首先必须通过字节码校验器的检查。</li>
<li>Java解释器将决定程序中类的内存布局。</li>
<li>类装载器负责把来自网络的类装载到单独的内存区域，避免应用程序之间相互干扰破坏。</li>
<li>客户端用户还可以限制从网络装载的类只能访问某些文件系统。</li>
</ol>
<h3 id="1-1-6-编译与解释并存"><a href="#1-1-6-编译与解释并存" class="headerlink" title="1.1.6 编译与解释并存"></a>1.1.6 编译与解释并存</h3><ol>
<li>用Java语言编写的程序称为源文件(扩展名为.java)</li>
<li>源文件不能被计算机执行，必须利用编译器将源文件编译成计算机能动的语言。</li>
<li>Java提供的编译器并不直接把源文件编译成二进制码，而是一种独立于机器平台的中间代码——字节码(扩展名为.class)。</li>
<li>字节码可以被Java解释器执行，翻译成二进制码使程序得以运行。</li>
</ol>
<p>Java语言通过字节码的方式，一定程度上解决了传统解释型语言执行效率低的问题，又保留了解释型语言可移植的特点。</p>
<h3 id="1-1-7-平台无关性"><a href="#1-1-7-平台无关性" class="headerlink" title="1.1.7 平台无关性"></a>1.1.7 平台无关性</h3><p>两种平台无关:</p>
<ol>
<li>源代码级<br>C/C++具有一定程度的源代码级平台无关，即用C和C++编写的语言不用修改只需重新编译就可以在不同平台上运行。</li>
<li>目标代码级<br>Java语言是靠Java虚拟机(JVM)在目标代码级实现平台无关性的。</li>
</ol>
<h3 id="1-1-8-多线程"><a href="#1-1-8-多线程" class="headerlink" title="1.1.8 多线程"></a>1.1.8 多线程</h3><p>线程是比进程更小的可并发执行的单位。</p>
<ol>
<li>Java环境本身就是多线程的。</li>
<li>Java语言内置多线程机制，可以大大简化多线程应用程序开发。</li>
<li>注意：Java语言的多线程在一定程度上收到运行时支持平台的限制。</li>
</ol>
<h3 id="1-1-9-支持网络编程"><a href="#1-1-9-支持网络编程" class="headerlink" title="1.1.9 支持网络编程"></a>1.1.9 支持网络编程</h3><p>同分布式特性</p>
<h2 id="1-2-Java技术简介"><a href="#1-2-Java技术简介" class="headerlink" title="1.2 Java技术简介"></a>1.2 Java技术简介</h2><ol>
<li>Java SE<br>Java平台的标准版，用于工作站，PC。</li>
<li>Java ME<br>Java平台的精简版，用于消费产品和嵌入式设备。</li>
<li>Java EE<br>Java平台的企业版，以企业为环境而开发应用程序的解决方案。</li>
</ol>
<h2 id="1-3-Java虚拟机"><a href="#1-3-Java虚拟机" class="headerlink" title="1.3 Java虚拟机"></a>1.3 Java虚拟机</h2><ol>
<li>字节码是JVM的指令组，和CPU上的微指令码很相似。</li>
<li>字节码文件尺寸较小，便于网络传输。</li>
<li>字节码最大的好处是可跨平台运行，无论使用哪种操作系统，字节码都可以在含有JVM的平台上运行。</li>
<li>JVM是一个字节码解释器，任何一种可以运行Java字节码的软件均可看作Java的“虚拟机”。</li>
</ol>
<h2 id="1-4-Java程序种类和结构"><a href="#1-4-Java程序种类和结构" class="headerlink" title="1.4 Java程序种类和结构"></a>1.4 Java程序种类和结构</h2><h3 id="1-4-1-两种程序类型-Application-应用程序-和Applet-小程序-。"><a href="#1-4-1-两种程序类型-Application-应用程序-和Applet-小程序-。" class="headerlink" title="1.4.1 两种程序类型:Application(应用程序)和Applet(小程序)。"></a>1.4.1 两种程序类型:Application(应用程序)和Applet(小程序)。</h3><ul>
<li>两者的开发原理相同，运行环境和计算结构却有显著区别。</li>
<li>Java应用程序在Java平台上单独运行，是单独完整的程序，只需要在命令行中调用独立的解释器软件即可运行。</li>
<li>Java应用程序的主类必须包含有一个定义为<code>public static void main(String[] args)</code>的主方法，这个方法是Java应用程序的标志，也是Java应用程序执行的入口点。</li>
<li>Java应用程序中包含有main()方法的类一定是主类，但主类并不一定要求是public类。</li>
<li>小程序是嵌入在HTML文档中的Java程序，需要搭配浏览器来运行。</li>
</ul>
<p>不同之处:</p>
<table>
<thead>
<tr>
<th>差别</th>
<th>Application</th>
<th>Applet</th>
</tr>
</thead>
<tbody><tr>
<td>运行环境</td>
<td>命令行</td>
<td>Web浏览器</td>
</tr>
<tr>
<td>外部输入</td>
<td>命令行参数</td>
<td>Web浏览器的大量信息</td>
</tr>
<tr>
<td>执行环境</td>
<td>非网络\内存较小的系统</td>
<td>Internet</td>
</tr>
<tr>
<td>图形界面</td>
<td>用专门代码营建</td>
<td>直接利用浏览器或AppletViewer</td>
</tr>
<tr>
<td>主类</td>
<td>包含主方法main()的类</td>
<td>继承自JApplet或Applet类且必须是public类</td>
</tr>
</tbody></table>
<h3 id="1-4-2-Java程序结构"><a href="#1-4-2-Java程序结构" class="headerlink" title="1.4.2 Java程序结构"></a>1.4.2 Java程序结构</h3><p>一般的Java源程序文件由三部分组成:</p>
<ul>
<li>package语句(0或1句)<br>表示本程序所属的包，如果有则必须写在最前面，没有则表示本程序属于默认包。</li>
<li>import语句(0或多句)<br>表示引入的其他类库的类，必须放在类定义的前面。</li>
<li>类定义(1或多个类定义)<br>Java源程序的主要部分，每个文件中可以定义若干个类。</li>
</ul>
<p>定义类的关键词是class，每个类的定义由类头定义和类体定义组成:</p>
<ul>
<li>类头部分用来声明类名，说明类的继承特性。</li>
<li>类体部分用来定义属性和方法这两种类的成员。</li>
</ul>
<p>类体中通常有两个组成部分:</p>
<ul>
<li>域: 包括变量、常量、对象数组等独立的实体。</li>
<li>方法: 类似于函数的代码单元块。</li>
</ul>
<p>方法体内不能在定义其他的方法。</p>
<p>语句是构成Java程序的基本单位之一，比语句更小的语言单位是表达式、变量、常量和关键字等等。</p>
<p>注意: Java是严格区分大小写的语言。</p>
<p>一个程序可以有多个类，但只能有一个主类。在Application中，这个主类是包含main()方法的类，不要求一定是public类。在Applet中，这个主类是继承自系统类JApplet或Applet的子类，且必须是public类。主类是Java程序执行的入口点。</p>
<h1 id="第二章-Java语言开发环境"><a href="#第二章-Java语言开发环境" class="headerlink" title="第二章 Java语言开发环境"></a>第二章 Java语言开发环境</h1><h2 id="2-1-Java开发工具"><a href="#2-1-Java开发工具" class="headerlink" title="2.1 Java开发工具"></a>2.1 Java开发工具</h2><ul>
<li>Java开发工具JDK(Java Development Kit)由Java API、Java运行环境和一组建立、测试工具的Java实用程序组成，核心是Java API。</li>
<li>Java API(Application Programming Interface)是Java提供的标准类库供编程人员使用，开发人员需要用这些类来实现Java语言的功能。</li>
<li>Java API包括一些重要的语言结构以及基本图形、网络和文件I/O等。</li>
<li>作为JDK的使用程序，工具库中的主要程序都放在JDK安装文件夹，子文件夹的内容如下：<ul>
<li>bin————存放几个常用的命令程序</li>
<li>db————包含Apache Derby 数据库等开放资源，支持JDBC4.0规范</li>
<li>include————存放与C程序相关的头文件</li>
<li>jre————存放Java运行环境(Java Runtime Environment,  JRE)相关的文件</li>
<li>lib————存放Java类库</li>
</ul>
</li>
<li>bin子文件夹中包含的几个常用命令:<ul>
<li>javac<br>Java编译器，将Java源代码文件转换成字节码文件</li>
<li>java<br>Java解释器，执行Java程序的字节码文件</li>
<li>apppletviewer<br>小程序浏览器，执行嵌入在HTML文件中的Java小程序的Java浏览器</li>
<li>javadoc<br>根据Java源代码及说明语句生成Java程序的HTML格式的帮助文档</li>
<li>jdb<br>Java调试器，可以逐行执行程序、设置断点和检查变量</li>
<li>jar<br>创建扩展名为.jar(Java Archieve,Java归档)的压缩文件，与zip压缩文件格式相同</li>
</ul>
</li>
</ul>
<h3 id="2-1-1-JDK的下载与安装"><a href="#2-1-1-JDK的下载与安装" class="headerlink" title="2.1.1 JDK的下载与安装"></a>2.1.1 JDK的下载与安装</h3><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ol>
<li>下载JDK<br>32位选择-i586.exe，64位选择-x64.exe</li>
<li>安装JDK<br>一路Next即可</li>
<li>设置JDK的环境变量<ul>
<li>系统变量Path:<code>C:\\Program File\xxx\bin;</code></li>
<li>类路径ClassPath:<code>.;C:\\Program File\xxx\lib\tools.jar</code></li>
</ul>
</li>
</ol>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li>tar.gz包解压，export环境变量</li>
<li><code>pacman -S jdk</code></li>
</ul>
<h3 id="2-1-2-安装库源文件和文档"><a href="#2-1-2-安装库源文件和文档" class="headerlink" title="2.1.2 安装库源文件和文档"></a>2.1.2 安装库源文件和文档</h3><ul>
<li>JDK安装目录下有<code>src.zip</code>压缩包，其中包含了所有公共类库的源代码。</li>
<li>JDK帮助文档需要在Oracle官网上独立下载，解压即可使用。</li>
<li>《Java核心技术 卷I》的程序示例在<code>http://horstmann.com/corejava</code>下，自行下载解压使用。</li>
</ul>
<h2 id="2-2-JDK的使用"><a href="#2-2-JDK的使用" class="headerlink" title="2.2 JDK的使用"></a>2.2 JDK的使用</h2><h3 id="2-2-1-使用命令行工具编译和运行代码"><a href="#2-2-1-使用命令行工具编译和运行代码" class="headerlink" title="2.2.1 使用命令行工具编译和运行代码"></a>2.2.1 使用命令行工具编译和运行代码</h3><p>以下内容均在Linux系统下进行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/java_exercise</span><br><span class="line">cd ~/java_exercise</span><br><span class="line">vim Welcome.java //这里我直接用vscode来写</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * This program displays a greeting for the reader.</span><br><span class="line"> * @version 1.0 2017-7-4</span><br><span class="line"> * @author qingqi</span><br><span class="line"> */</span><br><span class="line">public class Welcome</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        String greeting = &quot;Welcome to Core Java!&quot;;</span><br><span class="line">	System.out.println(greeting);</span><br><span class="line">	for (int i = 0; i &lt; greeting.length(); i++)</span><br><span class="line">	    System.out.print(&quot;=&quot;);</span><br><span class="line">	System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">javac Welcome.java</span><br><span class="line">java Welcome</span><br><span class="line"></span><br><span class="line">[Output]</span><br><span class="line"></span><br><span class="line">Welcome to Core Java!</span><br><span class="line">=====================</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-使用集成开发环境"><a href="#2-2-2-使用集成开发环境" class="headerlink" title="2.2.2 使用集成开发环境"></a>2.2.2 使用集成开发环境</h3><p>推荐使用全平台支持的Eclipse，下面是用Eclipse编写程序的一般步骤:</p>
<ol>
<li>启动Eclipse，从menu中选择File&gt;New&gt;Project。</li>
<li>从向导对话框中选择Java Project。</li>
<li>点击Next（用不用default location看你自己设置了，这里我们选择上文创建的Welcome.java所在的位置）。</li>
<li>点击Finish按钮，工程创建完成。</li>
<li>在工程窗口找到Welcome.java双击获得代码窗口。</li>
<li>鼠标右键点击工程名（Welcome），选择Run&gt;Run as application。程序输出会显示在控制台窗格。</li>
</ol>
<p>IDEA赛高！！！</p>
<h1 id="第三章-Java的基本程序设计结构"><a href="#第三章-Java的基本程序设计结构" class="headerlink" title="第三章 Java的基本程序设计结构"></a>第三章 Java的基本程序设计结构</h1><h2 id="3-1-一个简单的Java应用程序"><a href="#3-1-一个简单的Java应用程序" class="headerlink" title="3.1 一个简单的Java应用程序"></a>3.1 一个简单的Java应用程序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class FirstSample</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;We will not use&apos;Hello, World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序解析:</p>
<ol>
<li>Java区分大小写。</li>
<li>关键字public称为访问修饰符(access modifier),这些修饰符用于控制程序的其他部分对这段代码的访问级别。</li>
<li>关键字class表明Java程序中的所有内容都包括在类中。</li>
<li>class后面紧跟类名，标准的命名规范为:类名是以大写字母开头的名字，如果名字由多个单词组成，则每个单词的第一个字母都大写。(骆驼命名法)</li>
<li>源代码的文件名必须与公共类的类名相同，并用<code>.java</code>作为扩展名。</li>
<li>运行已编译的程序时，JVM从制定类中的main()方法开始执行，因此类的源文件必须包含一个main方法。</li>
<li>在Java、C/C++中，我们使用大括号来划分程序的各个部分(块)，推荐匹配的大括号上下对齐。</li>
<li>每个句子都必须使用<code>；</code>结束。</li>
<li><code>System.out.println()</code>这里，我们使用了System.out对象并调用了它的println方法。</li>
<li>Java与C/C++一样，都采用双引号分割字符串。</li>
<li>print()方法在输出之后不换行。</li>
</ol>
<h2 id="3-2-注释"><a href="#3-2-注释" class="headerlink" title="3.2 注释"></a>3.2 注释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This is the first sample grogram in Core Java Chapter</span><br><span class="line"> * @author tpwy</span><br><span class="line"> * @version 1.01</span><br><span class="line">  *  可以自动地生成文档</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class FirstSample &#123;</span><br><span class="line">	/*</span><br><span class="line">	 * This a sample example about core java</span><br><span class="line">	 */</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;We will not use &apos;Hello, World&apos;!&quot;); //Just one line</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-数据类型"><a href="#3-3-数据类型" class="headerlink" title="3.3 数据类型"></a>3.3 数据类型</h2><ul>
<li>Java是一门强类型语言，必须为每一个变量声明一种类型。</li>
<li>数据存储在内存的一块空间上，程序设计语言用变量名来代表该数据存储空间的位置。</li>
<li>数据类型定义了数据的性质、取值方位、存储方式以及对数据所能进行的运算和操作。</li>
<li>Java数据类型分为两大类:<ol>
<li>基本数据类型(primitive types)<ul>
<li>由程序设计语言系统所定义，不可再划分的数据类型</li>
<li>基本数据类型的数据所占内存大小是固定的</li>
<li>基本数据类型在内存中存放的是数据本身</li>
</ul>
</li>
<li>引用数据类型(reference types),简称引用类型<ul>
<li>引用类型在内存中存放的是指向该数据的地址，不是数据值本身。</li>
<li>往往由多个基本数据组成。</li>
<li>对引用数据类型的应用称为对象引用，引用数据类型也叫符合数据类型，在有的程序设计语言中称为指针。</li>
</ul>
</li>
</ol>
</li>
<li>Java语言定义了4类共8种基本数据结构<ul>
<li>整型——byte、short、int、long</li>
<li>浮点型——float、double</li>
<li>布尔型——boolean</li>
<li>字符型——char</li>
</ul>
</li>
</ul>
<h3 id="3-3-1-整型"><a href="#3-3-1-整型" class="headerlink" title="3.3.1 整型"></a>3.3.1 整型</h3><p>整型用来表示正整数、零和负整数。在Java中有三种进制的表示形式:</p>
<ul>
<li>十进制: 用多个0～9之间的数字表示，其首位不能为0；</li>
<li>八进制: 以0开头，后跟多个0～7之间的数字；</li>
<li>十六进制: 以0x或0X开头，后跟多个0～9之间的数字或a～f之间的小写字母或A～F之间的大写字母。</li>
</ul>
<p>补充:</p>
<p>Java7开始，加上前缀0b或0B就可以写二进制数，还可以为数字字面量加下划线以提高易读性。</p>
<p>四种整型的内容:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储需求</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1字节</td>
<td>$$-2^7～2^7-1$$</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>$$-2^15～2^15-1$$</td>
</tr>
<tr>
<td>int</td>
<td>4字节</td>
<td>$$-2^31～2^31-1$$</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>$$-2^63～2^63-1$$</td>
</tr>
</tbody></table>
<p>一个整数隐含为整型(int),int类型最常用，long类型的数值需要有一个后缀L或l。byte和short类型主要用于特定的应用场合，如底层的文件处理或者需要控制占用存储空间量的大数组。</p>
<p>与C/C++的区别:</p>
<ol>
<li>在Java中，整型的范围与运行Java的机器无关，所有的数值类型所占据的字节数量与平台无关。</li>
<li>Java没有任何无符号(unsigned)形式的int、long、short或byte类型。</li>
</ol>
<h3 id="3-3-2-浮点型"><a href="#3-3-2-浮点型" class="headerlink" title="3.3.2 浮点型"></a>3.3.2 浮点型</h3><p>浮点数的表示方法:</p>
<ul>
<li>标准计数法</li>
<li>科学计数法：eg 123.45可表示为<code>1.2345E+2</code></li>
</ul>
<p>两种浮点类型的具体内容:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储需求</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>±3.402 823 47E+38F(有效位数为6~7位)</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>±1.797 693 134 862 315 70E+308(有效位数为15位)</td>
</tr>
</tbody></table>
<p>一个浮点数隐含为double型，float类型的数值需要有一个后缀F或f。在很多情况下float类型的精度很难满足需求，所以一般采用double类型。</p>
<p>所有的浮点数值计算都遵循IEEE 754规范，具体表示溢出和出错的情况的三个特殊浮点数值:</p>
<ul>
<li>正无穷大——常量<code>Double.POSITIVE_INFINITY</code></li>
<li>负无穷大——常量<code>Double.NEGATIVE_INFINITY</code></li>
<li>NaN(不是一个数字)——常量<code>Double.NaN</code> eg.计算0/0或者负数的平方根</li>
</ul>
<p>注意: </p>
<ol>
<li><code>Double.NaN</code>的使用方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (x == Double.NaN) // is never true</span><br><span class="line"></span><br><span class="line">// 所有&quot;非数值&quot;的值都认为是不相同的，但可以用Double.NaN方法</span><br><span class="line"></span><br><span class="line">if (Double.NaN(x)) // check whether x is &quot;not a number&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li>浮点数值不适用与无法接受舍入误差的金融计算中，浮点数值采用二进制系统表示，无法精确的表示分数1/10。(就像十进制中无法精确的表示分数1/3一样)</li>
</ol>
<h3 id="3-3-3-boolean类型"><a href="#3-3-3-boolean类型" class="headerlink" title="3.3.3 boolean类型"></a>3.3.3 boolean类型</h3><p>boolean类型又称逻辑型，有两个值: false和true用来判断逻辑条件。整型值和布尔值之间不能进行互相转换。</p>
<p>与C/C++的区别:</p>
<p>在C++中，数值甚至指针可以替代boolean值。值0相当于false，1相当于true。</p>
<h3 id="3-3-4-char类型"><a href="#3-3-4-char类型" class="headerlink" title="3.3.4 char类型"></a>3.3.4 char类型</h3><ul>
<li>char类型原本用来表示单个字符，但现在有一些Unicode字符需要两个char值。(详细参考《Java核心技术 卷I》的3.3.4节)</li>
<li>Java语言中的字符采用的是Unicode字符编码方法，在内存中占两个字节，是16位无符号的整数，共65536个。Unicode字符使用”\u0000”到”\uFFFF”之间的十六位进制数来表示的。Unicode的采用加强了Java语言处理多语种的能力。</li>
<li>char类型的字面量要用单引号括起来。eg:<ul>
<li>‘A’是编码值为65所对应的字符常量</li>
<li>“A”是包含一个字符A的字符串</li>
</ul>
</li>
</ul>
<p>特殊字符的转义序列:</p>
<table>
<thead>
<tr>
<th>转义序列</th>
<th>名称</th>
<th>Unicode值</th>
</tr>
</thead>
<tbody><tr>
<td>\b</td>
<td>退格</td>
<td>\u0008</td>
</tr>
<tr>
<td>\t</td>
<td>制表</td>
<td>\u0009</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
<td>\u000a</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
<td>\u000d</td>
</tr>
<tr>
<td>&quot;</td>
<td>双引号</td>
<td>\u0022</td>
</tr>
<tr>
<td>&#39;</td>
<td>单引号</td>
<td>\u0027</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠</td>
<td>\u005c</td>
</tr>
</tbody></table>
<h2 id="3-4-关键字和标识符"><a href="#3-4-关键字和标识符" class="headerlink" title="3.4 关键字和标识符"></a>3.4 关键字和标识符</h2><h3 id="3-4-1-关键字"><a href="#3-4-1-关键字" class="headerlink" title="3.4.1 关键字"></a>3.4.1 关键字</h3><ul>
<li>关键字(keyword)也称保留字，是Java语言中被赋予特定含义的一些单词。Java语言不允许用户对关键字赋予其他的含义。</li>
<li>保留字(reversed word)包括包括关键字和未使用的保留字(在现有Java版本中尚未使用，但以后版本可以会作为关键字使用)</li>
</ul>
<p>Java定义的关键字如下:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>abstract</td>
<td>assert</td>
<td>boolean</td>
<td>break</td>
<td>byte</td>
<td>case</td>
</tr>
<tr>
<td>catch</td>
<td>char</td>
<td>class</td>
<td>continue</td>
<td>default</td>
<td>do</td>
</tr>
<tr>
<td>double</td>
<td>else</td>
<td>enum</td>
<td>extends</td>
<td>false</td>
<td>final</td>
</tr>
<tr>
<td>finally</td>
<td>float</td>
<td>for</td>
<td>if</td>
<td>implements</td>
<td>import</td>
</tr>
<tr>
<td>instanceof</td>
<td>int</td>
<td>interface</td>
<td>long</td>
<td>native</td>
<td>new</td>
</tr>
<tr>
<td>null</td>
<td>package</td>
<td>private</td>
<td>protected</td>
<td>publlic</td>
<td>return</td>
</tr>
<tr>
<td>short</td>
<td>static</td>
<td>super</td>
<td>switch</td>
<td>synchronized</td>
<td>this</td>
</tr>
<tr>
<td>throw</td>
<td>throws</td>
<td>transient</td>
<td>true</td>
<td>try</td>
<td>void</td>
</tr>
<tr>
<td>volatile</td>
<td>while</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="3-4-2-标识符"><a href="#3-4-2-标识符" class="headerlink" title="3.4.2 标识符"></a>3.4.2 标识符</h3><p>标识符(indentifier)是用来表示变量名、类名、方法名、数组名和文件名的有效字符序列。</p>
<p>标识符的规定:</p>
<ol>
<li>标识符可以由字母、数字和下划线、美元符号等组合而成；</li>
<li>标识符必须以字符、下划线或美元符号开头，不能以数字开头。</li>
</ol>
<p>实际应用中，标识符应具备一定程度的语义，关键字不能当做标识符来使用</p>
<p>编码习惯: 类名首字母大写；变量、方法和对象首字母小写。常量则大写所有字母，Java包(Package)属于特殊情况，所有字母小写。</p>
<h2 id="3-5-变量和常量"><a href="#3-5-变量和常量" class="headerlink" title="3.5 变量和常量"></a>3.5 变量和常量</h2><h3 id="3-5-1-变量"><a href="#3-5-1-变量" class="headerlink" title="3.5.1 变量"></a>3.5.1 变量</h3><p>变量具有四个基本要素: 1. 名字； 2. 类型； 3. 值； 4. 作用域(变量适用的f范围)</p>
<p>在Java中，每个变量都有一个类型(type), 声明变量时变量的类型位于变量名之前。eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double salary; //语句需要用分号结尾</span><br><span class="line">int x, y, z; //可以同时用分号声明多个变量，但不推荐使用</span><br><span class="line">long earthPopulation; //尽量避免乱七八糟的的符号，不允许使用空格</span><br></pre></td></tr></table></figure>

<p>声明变量后可以对变量进行初始化，即赋初值，没有赋值的变量不可以直接使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int vacationDays;</span><br><span class="line">vacationDays = 12;</span><br><span class="line"></span><br><span class="line">int vacationDays = 12; //建议变量的声明放在代码第一次使用的地方</span><br></pre></td></tr></table></figure>

<p>与C/C++的区别:</p>
<p>在C和C++区分变量的声明和定义。<br><code>int i = 10;</code><br>是一个定义，而<br><code>extern int i；</code><br>是一个声明。在Java中，不区分变量的声明和定义。</p>
<h3 id="3-5-2-常量"><a href="#3-5-2-常量" class="headerlink" title="3.5.2 常量"></a>3.5.2 常量</h3><p>在Java中，利用关键字<code>final</code>指示常量。eg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Constants</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        final double CM_PER_INCH = 2.54; </span><br><span class="line">        //final表示这个变量只能被赋值一次，赋值后就不能再更改，习惯上常量名适用全大写</span><br><span class="line">        double paperWidth = 8.5;</span><br><span class="line">        double paperHeight = 11;</span><br><span class="line">        System.out.println(&quot;Paper size in centimeter:&quot;</span><br><span class="line">            + paperWidth * CM_PER_INCH + &quot; by &quot; + paperHeight * CM_PER_INCH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果希望某个常量可以在一个类的多个方法中使用，通常将这个常量称为类常量，使用<code>static final</code>设置，需要注意类常量的定义位于main方法的外部。</li>
<li>如果一个变量被声明为<code>public</code>,那么其他类的方法也可以使用这个常量。</li>
</ul>
<h2 id="3-6-数字类型转换"><a href="#3-6-数字类型转换" class="headerlink" title="3.6 数字类型转换"></a>3.6 数字类型转换</h2><h3 id="3-6-1-数值型不同类型数据的转换"><a href="#3-6-1-数值型不同类型数据的转换" class="headerlink" title="3.6.1 数值型不同类型数据的转换"></a>3.6.1 数值型不同类型数据的转换</h3><p>数值型数据的类型转换分为隐含类型转换(或缺省类型转换)和强制类型转换。</p>
<h4 id="3-6-1-1-隐含类型转换"><a href="#3-6-1-1-隐含类型转换" class="headerlink" title="3.6.1.1 隐含类型转换"></a>3.6.1.1 隐含类型转换</h4><p>把占用比特数小的数据转换成占用比特数多的数据，由编译系统自动完成，不需要额外的说明。</p>
<p>需要满足的条件:</p>
<ul>
<li>转换前的数据类型与转换后的数据类型兼容</li>
<li>转换后的数据类型的表示范围比转换前的类型大</li>
</ul>
<p>转换数据的优先类型:</p>
<blockquote>
<p>(低)byte——short——char——int——long——float——double(高)</p>
</blockquote>
<ul>
<li>类型的转换只限于该语句本身，并不影响原先变量的类型定义。</li>
<li>在表达式中，为了避免溢出，会将数据进行”扩大转换”成相同的类型再进行计算。</li>
</ul>
<h4 id="3-6-1-2-强制类型转换"><a href="#3-6-1-2-强制类型转换" class="headerlink" title="3.6.1.2 强制类型转换"></a>3.6.1.2 强制类型转换</h4><p>强制类型转换(cast),也称显性转换。同样不影响原先变量的类型定义，但在转换过程中可能丢失部分信息。eg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double x = 9.997;</span><br><span class="line">int nx = (int) x; //x is 9</span><br><span class="line">int nx = (int) Math.round(x); //x is 10</span><br></pre></td></tr></table></figure>

<p>与C/C++的区别:</p>
<p>不要在boolean类型与任何数值类型之间进行强制类型转换。</p>
<h3 id="3-6-2-字符串型数据与整型数据相互转换"><a href="#3-6-2-字符串型数据与整型数据相互转换" class="headerlink" title="3.6.2 字符串型数据与整型数据相互转换"></a>3.6.2 字符串型数据与整型数据相互转换</h3><p>字符串转换成数据型数值的方法:</p>
<ul>
<li>Byte.parseByte(String s)</li>
<li>Short.parseShort(String s)</li>
<li>Integer.parseInt(String s)</li>
<li>Long.parseLong(String s)</li>
<li>Float.parseFloat(String s)</li>
<li>Double.parseDouble(String s)</li>
<li>Boolean.parseDouble(String s)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String myNumber = &quot;1234.567&quot;;</span><br><span class="line">float myFloat = Float.parseFloat(myNumber);</span><br></pre></td></tr></table></figure>

<p>数值型数据转换成字符串:可用加号来实现自动转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int myInt = 1234;</span><br><span class="line">String myString = &quot;&quot; + myInt;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-运算符"><a href="#3-7-运算符" class="headerlink" title="3.7 运算符"></a>3.7 运算符</h2><h3 id="3-7-1-算术运算符"><a href="#3-7-1-算术运算符" class="headerlink" title="3.7.1 算术运算符"></a>3.7.1 算术运算符</h3><h4 id="3-7-1-1-二元算术运算符"><a href="#3-7-1-1-二元算术运算符" class="headerlink" title="3.7.1.1 二元算术运算符"></a>3.7.1.1 二元算术运算符</h4><ul>
<li>两个整数之间做除法时，只保留整数部分而舍弃小数部分。</li>
<li>整数被0除将会产生一个异常，而浮点数被0除则会得到一个无穷大或NaN。</li>
<li>对于去模运算符<code>%</code>，其操作数可以是浮点数，此时<code>a % b</code>与<code>a - ((int)( a / b) * b</code>的语义相同，结果为除完后的浮点数部分。</li>
<li>加运算符<code>+</code>可以连接字符串，如<code>&quot;abc&quot; + &quot;de&quot;</code>可以得到<code>&quot;abcde&quot;</code></li>
</ul>
<h4 id="3-7-1-2-一元算术运算符"><a href="#3-7-1-2-一元算术运算符" class="headerlink" title="3.7.1.2 一元算术运算符"></a>3.7.1.2 一元算术运算符</h4><table>
<thead>
<tr>
<th>算术符</th>
<th>功能</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>正值</td>
<td>+a</td>
</tr>
<tr>
<td>-</td>
<td>负值</td>
<td>-a</td>
</tr>
<tr>
<td>++</td>
<td>加一</td>
<td>++a或a++</td>
</tr>
<tr>
<td>–</td>
<td>减一</td>
<td>–a或a–</td>
</tr>
</tbody></table>
<p>在表达式中使用自增与自减运算符时，前缀形式会先对操作数进行加一或减一运算后，再将结果用于表达式的操作；后缀形式则先进行表达式的操作后再对操作数进行加一或减一运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int m = 7;</span><br><span class="line">int n = 7;</span><br><span class="line">int a = x * ++m; // now a is 16, m is 8</span><br><span class="line">int b = x * n++; // now b is 14, n is 8</span><br></pre></td></tr></table></figure>

<p><strong>建议</strong>: 不要在表达式中使用++和–来自找麻烦。</p>
<h3 id="3-7-2-关系和boolean运算符"><a href="#3-7-2-关系和boolean运算符" class="headerlink" title="3.7.2 关系和boolean运算符"></a>3.7.2 关系和boolean运算符</h3><p>关系运算符有<code>&gt;、&lt;、&lt;=、&gt;=、==、!=</code>。注意不能在浮点数之间做<code>==</code>的比较，因为浮点数在表达上面难免有细小的误差存在，无法实现精确的相等。</p>
<p>逻辑运算符如下表所示:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
<th>实例</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>逻辑与</td>
<td>a &amp; b</td>
<td>两个操作数均为true时，结果才为true</td>
</tr>
<tr>
<td>|</td>
<td>逻辑或</td>
<td>a | b</td>
<td>两个操作数均为false时，结果才为false</td>
</tr>
<tr>
<td>！</td>
<td>逻辑非</td>
<td>!a</td>
<td>将操作数取反</td>
</tr>
<tr>
<td>^</td>
<td>异或</td>
<td>a ^ b</td>
<td>两个操作数同真或同减时，结果才为false</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>简洁与</td>
<td>a &amp;&amp; b</td>
<td>两个操作数均为true时，结果才为true</td>
</tr>
<tr>
<td>||</td>
<td>简洁或</td>
<td>a || b</td>
<td>两个操作数均为false时，结果才为false</td>
</tr>
</tbody></table>
<p>简洁运算与非简洁运算的区别在于：非简洁运算必须计算完左右两个表达式后才取结果，而简洁运算可能只取左边的表达式而不计算右边的表达式。</p>
<ul>
<li>对于<code>&amp;&amp;</code>，只要左边表达式为<code>false</code>，就不计算右边表达式，结果为<code>false</code></li>
<li>对于<code>||</code>，只要左边表达式为<code>true</code>，就不计算右边表达式，结果为<code>true</code></li>
</ul>
<p>推荐使用简洁运算</p>
<p>Java支持三元操作符<code>?:</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? expressionTrue : expressionFalse</span><br></pre></td></tr></table></figure>

<h3 id="3-7-3-位运算符"><a href="#3-7-3-位运算符" class="headerlink" title="3.7.3 位运算符"></a>3.7.3 位运算符</h3><p>位置运算符是对操作数以二进制比特位为单位进行的操作和运算，Java语言提供了如下的位运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
<th>示例</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>按位取反</td>
<td>~a</td>
<td>将ａ按比特位取反</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
<td>a &amp; b</td>
<td>将a按比特位相与</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>a | b</td>
<td>将a按比特位相或</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>a ^ b</td>
<td>将a按比特位相异或</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>a &gt;&gt; b</td>
<td>将a各比特位右移b位</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>a &lt;&lt; b</td>
<td>将a各比特位左移b位</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>0填充右移</td>
<td>a &gt;&gt;&gt; b</td>
<td>将a各比特位右移b位,左边的空位一律为0</td>
</tr>
</tbody></table>
<p>与C/C++的区别:</p>
<p>在C/C++中，不能保证&gt;&gt;是完成算术移位还是逻辑移位，Java则消除了这种不确型性。</p>
<h3 id="3-7-4-赋值运算符"><a href="#3-7-4-赋值运算符" class="headerlink" title="3.7.4 赋值运算符"></a>3.7.4 赋值运算符</h3><ol>
<li>赋值运算符可以形成连续赋值的情况，从右边开始执行。</li>
<li>扩展赋值运算符<ul>
<li>注意: 如果运算符得到一个值，其类型与左侧操作数的类型不同，就会发生强制转换。</li>
</ul>
</li>
</ol>
<p>eg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x</span><br><span class="line">x += 3.5 //the same as (int)(x + 3.5)</span><br></pre></td></tr></table></figure>

<h3 id="3-7-5-运算符优先级"><a href="#3-7-5-运算符优先级" class="headerlink" title="3.7.5 运算符优先级"></a>3.7.5 运算符优先级</h3><p>运算符优先级</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>[] .()(方法调用)</td>
<td>左–右</td>
</tr>
<tr>
<td>! ~ ++ – +(一元运算) -(一元运算) ()(强制类型转换) new</td>
<td>右–左</td>
</tr>
<tr>
<td>* / %</td>
<td>左–右</td>
</tr>
<tr>
<td>+ -</td>
<td>左–右</td>
</tr>
<tr>
<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
<td>左–右</td>
</tr>
<tr>
<td>&lt; &lt;= &gt; &gt;= instanceof</td>
<td>左–右</td>
</tr>
<tr>
<td>== !=</td>
<td>左–右</td>
</tr>
<tr>
<td>&amp;</td>
<td>左–右</td>
</tr>
<tr>
<td>^</td>
<td>左–右</td>
</tr>
<tr>
<td>|</td>
<td>左–右</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>左–右</td>
</tr>
<tr>
<td>||</td>
<td>左–右</td>
</tr>
<tr>
<td>?:</td>
<td>右–左</td>
</tr>
<tr>
<td>= += -= *= /= %= |= ^= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</td>
<td>右–左</td>
</tr>
</tbody></table>
<h2 id="3-8-枚举类型"><a href="#3-8-枚举类型" class="headerlink" title="3.8 枚举类型"></a>3.8 枚举类型</h2><p>自定义枚举类型:控制变量的取值在一个有限的集合内。<br>eg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum Size &#123; SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;</span><br><span class="line">Size s = Size.MEDIUM; //Size变量这能存储这个类型声明中给定的某个枚举值或者null</span><br><span class="line">// null表示这个变量没有设置任何值</span><br></pre></td></tr></table></figure>

<h2 id="3-9-字符串"><a href="#3-9-字符串" class="headerlink" title="3.9 字符串"></a>3.9 字符串</h2><p>Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类叫做String。用括号括起来的字符串都是String类的一个实例。</p>
<h3 id="3-9-1-创建字符串的三种格式"><a href="#3-9-1-创建字符串的三种格式" class="headerlink" title="3.9.1 创建字符串的三种格式"></a>3.9.1 创建字符串的三种格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//格式一：</span><br><span class="line">String s; //声明字符串引用变量s，此时s的值为null</span><br><span class="line">s = new String(&quot;hello&quot;); //在堆内存中分配空间，并将s指向该字符串首地址</span><br><span class="line"></span><br><span class="line">//格式二：</span><br><span class="line">String s = new String(&quot;hello&quot;); //格式一的合并</span><br><span class="line"></span><br><span class="line">//格式三：</span><br><span class="line">String s = &quot;hello&quot;; //直接为新建的String对象赋值，在声明变量时直接初始化</span><br><span class="line"></span><br><span class="line">//推荐使用格式三</span><br></pre></td></tr></table></figure>

<h3 id="3-9-2-字符串的几种常用方法"><a href="#3-9-2-字符串的几种常用方法" class="headerlink" title="3.9.2 字符串的几种常用方法"></a>3.9.2 字符串的几种常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 子串</span><br><span class="line">String greeting = &quot;Hello&quot;;</span><br><span class="line">String s = greeting.substring(0, 3);</span><br><span class="line"></span><br><span class="line">// 拼接</span><br><span class="line">String expletive = &quot;Expletive&quot;;</span><br><span class="line">String PG13 = &quot;deleted&quot;;</span><br><span class="line">String message = expletetive + PG13;</span><br><span class="line"></span><br><span class="line">//多个字符串拼接</span><br><span class="line">String all = String.join(&quot;/&quot;, &quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;);//all is the string&quot;S/M/L/ML&quot;</span><br><span class="line"></span><br><span class="line">//检测字符串是否相等</span><br><span class="line">&quot;Hello&quot;.equals(greeting);</span><br><span class="line">&quot;Hello&quot;.equalsIgnoreCase(&quot;hello&quot;); //不区分大小写</span><br><span class="line">//不要使用 == 来检测两个字符串是否相等，这个运算只能确定它们是否放置在同一位置上</span><br></pre></td></tr></table></figure>

<p>与C/C++的区别:</p>
<p>Java不能直接修改字符串，String类对象称为不可变字符串，大致类似于C中的char*指针，而非字符型数组。</p>
<h3 id="3-9-3-空串和null串"><a href="#3-9-3-空串和null串" class="headerlink" title="3.9.3 空串和null串"></a>3.9.3 空串和null串</h3><ul>
<li>空串<code>&quot;&quot;</code>是长度为0的字符串，是一个Java对象，有自己的串长度(0)和内容(空)</li>
<li>String变量还可以存放一个特殊的值，名为null，这表示目前没有任何对象与该变量关联。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//检验字符串是否为空</span><br><span class="line">if (str.length() == 0)</span><br><span class="line">if (str.equals(&quot;&quot;))</span><br><span class="line"></span><br><span class="line">//检查一个字符串是否为null</span><br><span class="line">if (str == null)</span><br></pre></td></tr></table></figure>

<h2 id="3-10-输入输出"><a href="#3-10-输入输出" class="headerlink" title="3.10 输入输出"></a>3.10 输入输出</h2><h3 id="3-10-1-读取输入"><a href="#3-10-1-读取输入" class="headerlink" title="3.10.1 读取输入"></a>3.10.1 读取输入</h3><p>读取”标准输入流”System.in需要构造一个Scanner对象，并与”标准输入流”System.in”相关联。eg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class LinputTest &#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		String s1, s2;</span><br><span class="line">		Scanner reader = new Scanner(System.in);</span><br><span class="line">		System.out.print(&quot;the frist number： &quot;);</span><br><span class="line">		s1 =  reader.nextLine(); </span><br><span class="line">		System.out.print(&quot;the second number： &quot;);</span><br><span class="line">		s2 = reader.nextLine();</span><br><span class="line">		System.out.println(&quot;what you input is &quot; + s1 + &quot; and &quot; + s2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<ul>
<li><code>next()</code>方法会自动去掉输入有效符号之前的空格键、Tab键和回车键等，只有输入有效符号之后才会对将它们视为分隔符或结束符。</li>
<li><code>nextLine()</code>方法将读取一整行的所有字符，直到遇到作为结束符的回车键。</li>
<li><code>HasNextXXX()</code>方法将会判断用户输入是否是相应类型的数据，<code>nextXXX()</code>方法则对输入进行读取。</li>
<li><code>Scanner</code>类定义在java.util包中，需要使用<code>import</code>加载。</li>
</ul>
<p>要想读取一个密码，可以采用以下的示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Console cons = System.console();</span><br><span class="line">String username = cons.readLine(&quot;User name: &quot;);</span><br><span class="line">char[] passed = cons.readPassword(&quot;Password: &quot;);</span><br></pre></td></tr></table></figure>

<h3 id="3-10-2-格式化输出"><a href="#3-10-2-格式化输出" class="headerlink" title="3.10.2 格式化输出"></a>3.10.2 格式化输出</h3><p>使用<code>printf</code>方法。eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double x = 1000.0 / 3.0;</span><br><span class="line">// 8个字符的宽度和小数点后两个字符的精度打印x</span><br><span class="line">System.out.printf(&quot;%8.2f&quot;, a);</span><br></pre></td></tr></table></figure>

<p>用于<code>printf</code>的转换符</p>
<table>
<thead>
<tr>
<th>转换符</th>
<th>类型</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>d</td>
<td>十进制整位</td>
<td>159</td>
</tr>
<tr>
<td>x</td>
<td>十六进制整位</td>
<td>9f</td>
</tr>
<tr>
<td>o</td>
<td>八进制整位</td>
<td>237</td>
</tr>
<tr>
<td>f</td>
<td>定点浮点数</td>
<td>15.9</td>
</tr>
<tr>
<td>e</td>
<td>指数浮点数</td>
<td>1.59e+01</td>
</tr>
<tr>
<td>s</td>
<td>字符串</td>
<td>Hello</td>
</tr>
<tr>
<td>c</td>
<td>字符</td>
<td>H</td>
</tr>
<tr>
<td>b</td>
<td>布尔</td>
<td>True</td>
</tr>
<tr>
<td>tx或Tx</td>
<td>日期时间</td>
<td>已过时，应使用java.time类</td>
</tr>
<tr>
<td>%</td>
<td>百分号</td>
<td>%</td>
</tr>
</tbody></table>
<h3 id="3-10-3-文件输入与输出"><a href="#3-10-3-文件输入与输出" class="headerlink" title="3.10.3 文件输入与输出"></a>3.10.3 文件输入与输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 读取文件</span><br><span class="line">Scanner in = new Scanner(path.get(&quot;myfile.txt&quot;), &quot;UTF-8&quot;); //指定使用UTF-8字符编码</span><br><span class="line"></span><br><span class="line">// 写入文件</span><br><span class="line">PrintWriter out = new PrintWriter(&quot;myfile.txt&quot;, &quot;UTF-8&quot;); //如果文件不存在，则创建它</span><br><span class="line"></span><br><span class="line">//注意：相对路径的从Java虚拟机启动的当前路径出发的，可以通过一下调用找到路径位置</span><br><span class="line">String dir = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line"></span><br><span class="line">//如果觉得定位路径麻烦的话可以采用绝对路径</span><br><span class="line"></span><br><span class="line">// 用一个不存在的文件构造一个Scanner或用一个不能被创建的文件名构造PrintWriter会发生异常。</span><br><span class="line"></span><br><span class="line">// 我们需要告知编译器：已经知道有可能出现&quot;输入/输出&quot;异常。这需要在main方法中用throws字句标记</span><br><span class="line">public static void main(String[] args) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">    Scanner in = new Scanner(path.get(&quot;myfile.txt&quot;), &quot;UTF-8&quot;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-11-控制流程"><a href="#3-11-控制流程" class="headerlink" title="3.11 控制流程"></a>3.11 控制流程</h2><p>与C/C++的区别:</p>
<ul>
<li>Java没有<code>goto</code>语句，但支持带标签的<code>break</code>语句。</li>
<li>不能在嵌套的两个块(符合语句)声明同名变量。</li>
<li>Java中的<code>if()</code>和<code>else if()</code>语句中条件表达式的奇偶过必须是逻辑型量。</li>
<li><code>do-while</code>语句先执行循环体代码块再检测循环条件。</li>
<li>如果希望在for语句之外使用循环计数器的最终值，就要确保这个变量在循环语句前面并且在外部声明!</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">// i no longer defined here</span><br><span class="line"></span><br><span class="line">int i;</span><br><span class="line">for (i = 1; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">// i is stil here</span><br></pre></td></tr></table></figure>

<ul>
<li><code>switch</code>语句与C/C++完全一样,如果没有使用<code>break</code>语句，将实现不同判断语句流入相同分支的效果。</li>
<li><code>switch</code>的case标签可以是：1. char、byte、short或int的常量表达式；2. 枚举常量(不需要指明枚举名)； 2. 字符串字面量</li>
<li>不推荐使用<code>switch</code>语句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class LinputTest</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		int month, day;</span><br><span class="line">		Scanner reader = new Scanner(System.in);</span><br><span class="line">		System.out.println(&quot;请输入月份&quot;);</span><br><span class="line">		month = reader.nextInt();</span><br><span class="line">		switch (month)</span><br><span class="line">		&#123;</span><br><span class="line">			case 2:</span><br><span class="line">				day = 28;</span><br><span class="line">				break;</span><br><span class="line">			case 4:</span><br><span class="line">			case 6:</span><br><span class="line">			case 9:</span><br><span class="line">			case 11:</span><br><span class="line">				day = 30;</span><br><span class="line">				break;</span><br><span class="line">			default:</span><br><span class="line">				day = 31;</span><br><span class="line">                break;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(month + &quot;月份有&quot; + day + &quot;天&quot;);</span><br><span class="line">		reader.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>与C++不同，Java提供了一种带标签的<code>break</code>语句来跳出多重嵌套的循环语句，注意标签必须紧跟一个冒号</li>
<li>注意区分<code>break</code>和<code>continue</code>语句，如果容易混淆的话则尽量不使用这两个语句。</li>
</ul>
<h2 id="3-12-大数值"><a href="#3-12-大数值" class="headerlink" title="3.12 大数值"></a>3.12 大数值</h2><p><code>java.math</code>包中的两个常用类：<code>BigInteger</code>和<code>BigDecimal</code>可以处理任意精度的整数运算和浮点数运算</p>
<ul>
<li>使用静态的<code>valueOf</code>方法将普通数值转换成大数值：<code>BigInterger a = BigInterger.valueOf(100);</code></li>
<li>不能使用人们熟悉的算术运算符来处理大数值。</li>
<li>与C++不同，Java没有提供运算符重载功能。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger c = a.add(b); // c = a + b</span><br><span class="line">BigInteger d = c.multiply(b.add(BigInteger.valueOf(2))); // d = c * (b + 2)</span><br></pre></td></tr></table></figure>

<h2 id="3-13-数组"><a href="#3-13-数组" class="headerlink" title="3.13 数组"></a>3.13 数组</h2><h3 id="3-13-1-基本概念"><a href="#3-13-1-基本概念" class="headerlink" title="3.13.1 基本概念"></a>3.13.1 基本概念</h3><p>数组是用来存储相同数据类型值的集合，通过整型下标可以访问数值中的每一个元素。</p>
<h3 id="3-12-2-内存分配"><a href="#3-12-2-内存分配" class="headerlink" title="3.12.2 内存分配"></a>3.12.2 内存分配</h3><p>Java语言的内存分为栈内存和堆内存</p>
<ul>
<li>栈内存: 在方法中定义的一些基本类型的变量和对象的引用变量都在方法的栈内存中分配。<ul>
<li>当在一段代码块定义一个变量时，Java就在栈内存中为这个变量分配内存空间</li>
<li>超出变量的作用域后，Java会自动释放掉为该变量所分配的内存空间</li>
</ul>
</li>
<li>堆内存： 用来存放由<code>new</code>运算符创建的对象和数组，在堆中分配的内存由Java虚拟机的自动垃圾回收器来管理<ul>
<li>在堆中创建一个数组或对象后，同时还在栈中定义一个特殊的变量，该变量的取值等于数组或对象在堆内存的首地址，即该变量就成了数组或对象的引用变量</li>
<li>引用变量在运行到其作用域外后被释放，而数组或对象本身还在堆内存中没有被释放；</li>
<li>数组或对象没有引用变量指向它时，会变成垃圾，无法再被使用，但仍占用内存空间，在随后一个不确定的时间被垃圾回收器释放掉，这也是Java比较占内存的原因</li>
</ul>
</li>
</ul>
<h3 id="3-12-3-一维数组"><a href="#3-12-3-一维数组" class="headerlink" title="3.12.3 一维数组"></a>3.12.3 一维数组</h3><p>声明数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] a = new int[100]; //创建一个可以存储100个整数的数组</span><br><span class="line">int a[]; //也可以这样声明数组，但推荐上面的风格</span><br><span class="line"></span><br><span class="line">int* a = new int[100]; //C++,与上述语句等同</span><br></pre></td></tr></table></figure>

<ol>
<li>创建一个数字数组时，所有元素都初始化为0；</li>
<li><code>boolean</code>数组的元素都初始化为<code>false</code>；</li>
<li>对象数组的元素都初始化为<code>null</code>。如果希望这个数组包含空串，可以使用<code>for (int i = 0; i &lt; a.length; i++) 数组名[i] = &quot;&quot;;</code></li>
<li>一旦创建了数组，就不能再改变数组的大小了(但可以改变每一个数组元素)，如果需要在运行过程中扩展数组的大小，则应该使用“数组列表”(array list)。</li>
<li>利用<code>new</code>运算符为数组元素分配内存空间的方式称为动态内存分配方式</li>
</ol>
<p>一维数组的初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] smallPrice = &#123;2, 3, 4, 5, 6&#125;; // 不需要调用new运算符</span><br><span class="line">new int[] &#123;2, 3, 4, 5, 6&#125;; // 创建匿名数组</span><br><span class="line">smallPrice = new int[] &#123;7, 8, 9, 10, 11, 12&#125;; // 在不创建新变量的情况下重新初始化smallPrice</span><br><span class="line"></span><br><span class="line">new elementType[0]; //创建长度为0的数组</span><br></pre></td></tr></table></figure>

<p>数组拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] luckyNumbers = smallPrimes; // 两个变量引用同一个数组</span><br><span class="line">LuckyNumbers[5] = 12; // now smallPrimes[5] is also 12</span><br><span class="line">int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, 2  * luckyNumbers.length); // 第二个参数是新数组的长度，常用于扩展新数组</span><br></pre></td></tr></table></figure>

<p>命令行参数</p>
<p>每一个Java应用参数都有一个带<code>String arg[]</code>参数的<code>main</code>方法。这个参数表示<code>main</code>方法将接收一个字符串数组，也就是命令行参数</p>
<p>与C/C++的区别: 在Java应用程序的<code>main</code>方法中，程序名并没有存储在<code>args</code>数组中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Example3_12_3</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        if (args.length == 0 || args[0].equals(&quot;-h&quot;))</span><br><span class="line">            System.out.print(&quot;Hello, &quot;);</span><br><span class="line">        else if(args[0].equals(&quot;-g&quot;))</span><br><span class="line">            System.out.print(&quot;Googbye, &quot;);</span><br><span class="line">        for (int i = 1; i &lt; args.length; i++)</span><br><span class="line">            System.out.print(&quot;&quot; + args[i] + &quot; &quot;);</span><br><span class="line">        System.out.println(&quot;!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-12-4-foreach-语句"><a href="#3-12-4-foreach-语句" class="headerlink" title="3.12.4 foreach 语句"></a>3.12.4 <code>foreach</code> 语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">for (type element: collection) statement</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">int[] a = &#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">for (int element: a)</span><br><span class="line">    System.out.println(element);</span><br><span class="line"></span><br><span class="line">// 等同于for循环</span><br><span class="line">for (int i = 0; i &lt; a.lenth; i++)</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line"></span><br><span class="line">// 简单打印数组的所有值</span><br><span class="line">System.out.println(Arrays.toSprint(a));</span><br></pre></td></tr></table></figure>

<h3 id="3-12-5-多维数组"><a href="#3-12-5-多维数组" class="headerlink" title="3.12.5 多维数组"></a>3.12.5 多维数组</h3><p>我们常用二维数组(也称矩阵)来存储表格信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//创建二维数组</span><br><span class="line">int[][] a; //声明矩阵</span><br><span class="line">a = new int[3][4] //分配一块内存空间，供3行4列的整型数组a使用</span><br><span class="line"></span><br><span class="line">//不调用new来初始化</span><br><span class="line">int[][] magicSquare = </span><br><span class="line">    &#123;</span><br><span class="line">        &#123;16, 3, 2, 13&#125;, </span><br><span class="line">        &#123;5, 10, 11, 8&#125;, </span><br><span class="line">        &#123;9, 6, 7, 12&#125;,</span><br><span class="line">        &#123;4, 15, 14, 1&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//创建不规则矩阵</span><br><span class="line">int[][] x;</span><br><span class="line">x = new int[3][]; //矩阵行数为3</span><br><span class="line">x[0] = new int[3]; //第一行列数为3，此时x[0]是数组的引用变量</span><br><span class="line">x[1] = new int[2]; //第二行列数为2</span><br><span class="line"></span><br><span class="line">//多维数组</span><br><span class="line">int[][][] b; //声明三维数组，其他数组依此类推</span><br><span class="line"></span><br><span class="line">//快速打印多维数组的元素列表</span><br><span class="line">System.out.println(Arrays.deepTostring(magicSquare));</span><br></pre></td></tr></table></figure>

<h1 id="第四章-对象和类-课本"><a href="#第四章-对象和类-课本" class="headerlink" title="第四章 对象和类(课本)"></a>第四章 对象和类(课本)</h1><p>由于《Java程序设计基础 第五版》和《Java核心技术 卷I》在这一部分内容相差较大，这里以课本为基础篇，《Core Java》作为补充扩展。</p>
<h2 id="4-1-类的基本概念"><a href="#4-1-类的基本概念" class="headerlink" title="4.1 类的基本概念"></a>4.1 类的基本概念</h2><ol>
<li>类的概念是为了让程序程序设计语言能更清楚的描述日常生活中的事物</li>
<li>类是对某一类事物的描述，是抽象的、概念上的定义</li>
<li>对象则是实际存在的属该类事物的具体的个体，也称为实例(instance)</li>
<li>面向对象程序设计(OOP)思想的重点是类的设计而不是对象的设计</li>
</ol>
<p>一般来说，类是由数据成员与函数成员封装而成的，其中数据成员表示类的属性，函数成员表示类的行为</p>
<ul>
<li>Java语言将类内的数据成员称为field(域)[域变量、属性、成员变量]，将封装于类内的函数称为method(方法)[成员方法]</li>
</ul>
<h2 id="4-2-定义类"><a href="#4-2-定义类" class="headerlink" title="4.2 定义类"></a>4.2 定义类</h2><p>用户定义一个类实际上就是定义一个新的数据类型。在使用类之前必须先定义才能利用所定义的类来声明相应的变量并创建对象。</p>
<h3 id="4-2-1-类的一般结构"><a href="#4-2-1-类的一般结构" class="headerlink" title="4.2.1 类的一般结构"></a>4.2.1 类的一般结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[类修饰符] class 类名称 //修饰符是可选项</span><br><span class="line">&#123;</span><br><span class="line">    [修饰符] 数据类型 成员变量名称; //声明成员变量</span><br><span class="line">    ...</span><br><span class="line">    [修饰符] 返回值的数据类型 方法名(参数1, 参数2,...) //声明成员方法</span><br><span class="line">    &#123;</span><br><span class="line">        语句序列</span><br><span class="line">        return [表达式];</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四种类修饰符的含义"><a href="#四种类修饰符的含义" class="headerlink" title="四种类修饰符的含义"></a>四种类修饰符的含义</h4><table>
<thead>
<tr>
<th>修饰符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>当一个类声明为公共类，它可以被任何对象访问</td>
</tr>
<tr>
<td>abstract</td>
<td>当一个类声明为抽象类，没有实现方法，需要子类提供方法的实现，所有不能创建该类的实例</td>
</tr>
<tr>
<td>final</td>
<td>当一个类声明为最终类(非继承类)，表示它不能被其他类所继承</td>
</tr>
<tr>
<td>缺省</td>
<td>表示只有在相同包中的对象才能使用这个类</td>
</tr>
</tbody></table>
<p>一个类可以有多个修饰符，且无前后顺序之分，但abstract和final相互对立，不能一起应用在一个类的定义上</p>
<h3 id="4-2-2-成员变量"><a href="#4-2-2-成员变量" class="headerlink" title="4.2.2 成员变量"></a>4.2.2 成员变量</h3><h4 id="4-2-2-1-成员变量修饰符的含义"><a href="#4-2-2-1-成员变量修饰符的含义" class="headerlink" title="4.2.2.1 成员变量修饰符的含义"></a>4.2.2.1 成员变量修饰符的含义</h4><table>
<thead>
<tr>
<th>修饰符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>公共访问控制符，指定该变量为公共的，可以被任何对象的方法访问</td>
</tr>
</tbody></table>
<p>| private | 私人访问控制符，指定该变量只允许自己类的方法访问，其他任何类(包括子类)中的方法均不能访问该变量<br>| protected | 保护访问控制符，该变量只可以在被它自己的类及其子类或同一个包中的其他类访问，在子类可以覆盖这个变量<br>| 缺省 | 缺省访问控制符，同一个包中的其他类可以访问此成员变量，而其他包中的类不能访问该成员变量 |<br>| final | 最终修饰符，指定此变量的值不能改变 |<br>| static | 静态修饰符，指定此变量被所有对象共享，即所有的实例都可以使用该变量 |<br>| transient | 过度修饰符，指定该变量是一个系统保留，暂无特别作用的临时性变量 |<br>| volatile | 易失修饰符，指定该变量可以同时被几个线程控制和修改 |</p>
<p>除了访问控制符有多个之外，其他的修饰符都只有一个。一个成员变量可以被多个修饰符同时修饰，但有些修饰符不能同时定义在一起。</p>
<h4 id="4-2-2-2-成员变量与局部变量的区别"><a href="#4-2-2-2-成员变量与局部变量的区别" class="headerlink" title="4.2.2.2 成员变量与局部变量的区别"></a>4.2.2.2 成员变量与局部变量的区别</h4><p>类和方法中均可以定义属于自己的变量，类中定义的变量是成员变量，方法中定义的变量是局部变量</p>
<ol>
<li>语法形式上看，成员变量属于类，局部变量是在方法中定义的变量或是方法的参数。成员变量可以被public、private、static等修饰符所修饰，而局部变量则不能被访问控制修饰符及static修饰。两者都可以被final修饰</li>
<li>从变量在内存中的存储方式上看，成员变量是对象的一部分，对象时存在与堆内存的，而局部变量是存在于栈内存的</li>
<li>从变量在内存中的生存时间来看，成员变量随对象的创建而存在。局部变量随方法的调用而产生，随着方法调用的结束而自动消失</li>
<li>成员变量如果没有被赋初值，则自动以类型的默认值赋值(但被final修饰但没有被static修饰的成员变量必须显式地赋值)；而局部变量则不会自动赋值，必须显式地赋值后才能被使用</li>
</ol>
<h3 id="4-2-3-成员方法"><a href="#4-2-3-成员方法" class="headerlink" title="4.2.3 成员方法"></a>4.2.3 成员方法</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>同上</td>
</tr>
<tr>
<td>private</td>
<td>同上</td>
</tr>
<tr>
<td>protect</td>
<td>同上</td>
</tr>
<tr>
<td>缺省</td>
<td>同上</td>
</tr>
<tr>
<td>final</td>
<td>指定该方法不能被重载</td>
</tr>
<tr>
<td>static</td>
<td>指定不需要实例化一个对象就可以调用的方法</td>
</tr>
<tr>
<td>abstract</td>
<td>指定该方法之生命方法头，而没有方法体，方法体需在子类中被实现</td>
</tr>
<tr>
<td>synchronized</td>
<td>同步修饰符，在多线程程序中，该修饰符用在运行前，对它所属的方法加锁以防止被其他线程访问，运行结束后解锁</td>
</tr>
<tr>
<td>native</td>
<td>本地修饰符，指定此方法的方法体是用其他语言(如C)在程序外部编写的</td>
</tr>
</tbody></table>
<p>成员方法同样可以有多个控制修饰符，多个修饰符时候要注意是否互斥</p>
<h2 id="4-3-对象的创建和使用"><a href="#4-3-对象的创建和使用" class="headerlink" title="4.3 对象的创建和使用"></a>4.3 对象的创建和使用</h2><p>一个对象的生命周期是： 创建——使用——销毁</p>
<h3 id="4-3-1-创建对象"><a href="#4-3-1-创建对象" class="headerlink" title="4.3.1 创建对象"></a>4.3.1 创建对象</h3><p>两个步骤</p>
<ol>
<li>声明指向”由类所创建的对象”的引用变量</li>
<li>利用<code>new</code>运算符创建新的对象，并指派给前面所创建的变量</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cylinder volu;</span><br><span class="line">volu = new Cylinder();</span><br><span class="line"></span><br><span class="line">Cylinder volu = new Cylinder(); //简写</span><br></pre></td></tr></table></figure>

<p>成员变量的初始值</p>
<table>
<thead>
<tr>
<th>成员变量类型</th>
<th>初始值</th>
</tr>
</thead>
<tbody><tr>
<td>byte、short、int</td>
<td>0</td>
</tr>
<tr>
<td>long、float、double</td>
<td>0L、0F、0D</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’(表示为空)</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>所有引用类型</td>
<td>null</td>
</tr>
</tbody></table>
<h3 id="4-3-2-对象的使用"><a href="#4-3-2-对象的使用" class="headerlink" title="4.3.2 对象的使用"></a>4.3.2 对象的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Cylinder &#123;</span><br><span class="line"></span><br><span class="line">    double radius;</span><br><span class="line">    double height;</span><br><span class="line">    final double PI = 3.14;</span><br><span class="line"></span><br><span class="line">    double area() &#123;</span><br><span class="line">        return PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double volume() &#123;</span><br><span class="line">        return this.area() * height; </span><br><span class="line">        //类定义内可以直接调用自己的方法,使用this关键字来强调是对象本身的成员</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Example4_3_2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Cylinder volu;</span><br><span class="line">        volu = new Cylinder();</span><br><span class="line">        volu.height = 5;</span><br><span class="line">        volu.radius = 2.8;</span><br><span class="line">        System.out.println(&quot;半径为 &quot; + volu.radius);</span><br><span class="line">        System.out.println(&quot;高为 &quot; + volu.height);</span><br><span class="line">        System.out.println(&quot;底面积为&quot; + volu.area());</span><br><span class="line">        System.out.println(&quot;体积为 &quot; + volu.volume());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-参数的传递"><a href="#4-4-参数的传递" class="headerlink" title="4.4 参数的传递"></a>4.4 参数的传递</h2><h3 id="4-4-1-以变量为参数调用方法"><a href="#4-4-1-以变量为参数调用方法" class="headerlink" title="4.4.1 以变量为参数调用方法"></a>4.4.1 以变量为参数调用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Cylinder &#123;</span><br><span class="line"></span><br><span class="line">    double radius;</span><br><span class="line">    double height;</span><br><span class="line">    final double PI = 3.14;</span><br><span class="line">    void setCylinder(double r, double h) &#123;</span><br><span class="line">        this.radius = r;</span><br><span class="line">        this.height = h;</span><br><span class="line">    &#125;</span><br><span class="line">    double area() &#123;</span><br><span class="line">        return PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double volume() &#123;</span><br><span class="line">        return this.area() * height; //类定义内可以直接调用自己的方法,使用this关键字来强调是对象本身的成员</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Example4_3_2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Cylinder volu;</span><br><span class="line">        volu = new Cylinder();</span><br><span class="line">        volu.setCylinder(2.8, 5); //接收传递的参数</span><br><span class="line">        System.out.println(&quot;半径为 &quot; + volu.radius);</span><br><span class="line">        System.out.println(&quot;高为 &quot; + volu.height);</span><br><span class="line">        System.out.println(&quot;底面积为&quot; + volu.area());</span><br><span class="line">        System.out.println(&quot;体积为 &quot; + volu.volume());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<code>setCylinder()</code>方法中的<code>r、h</code>都是局部变量，一旦离开该方法就失去作用</p>
<p>说明：当方法的形式参数和类的成员变量同名的时候，需要使用<code>this</code>关键字来表示成员变量</p>
<h3 id="4-4-2-以数组作为参数或返回值的方法调用"><a href="#4-4-2-以数组作为参数或返回值的方法调用" class="headerlink" title="4.4.2 以数组作为参数或返回值的方法调用"></a>4.4.2 以数组作为参数或返回值的方法调用</h3><ol>
<li>传递参数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class LeastNumb</span><br><span class="line">&#123;</span><br><span class="line">    public void least(int[] array)</span><br><span class="line">    &#123;</span><br><span class="line">        int tmp = array[0];</span><br><span class="line">        for (int i=1; i&lt;array.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (tmp &gt; array[i])</span><br><span class="line">                tmp = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;最小值为 &quot; + tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Example4_4_2 &#123;</span><br><span class="line">    public static void  main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        int[] a = &#123;8, 3, 7, 88, 9, 23&#125;;</span><br><span class="line">        LeastNumb minNumber = new LeastNumb();</span><br><span class="line">        minNumber.least(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>返回值为数组类型的方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class trans</span><br><span class="line">&#123;</span><br><span class="line">    int tmp;</span><br><span class="line">    int[][] transponse(int[][] array)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; array[i].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = array[i][j];</span><br><span class="line">                array[i][j] = array[j][i];</span><br><span class="line">                array[j][i] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Example4_4_3 &#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        int[][] a = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;;</span><br><span class="line">        trans pose = new trans();</span><br><span class="line">        int[][] b = pose.transponse(a);</span><br><span class="line">        for(int i = 0; i &lt; b.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j = 0; j &lt; b[i].length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(b[i][j] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.print(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-匿名对象"><a href="#4-5-匿名对象" class="headerlink" title="4.5 匿名对象"></a>4.5 匿名对象</h2><p>当一个对象被创建之后，在调用该对象的方法时，也可以不定义对象的引用变量，而直接调用这个对象的方法。这样的对象称为匿名对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cylinder volu = new Cylinder();</span><br><span class="line">volu.setCylinder(2.5, 5);</span><br><span class="line"></span><br><span class="line">new Cylinder().setCylinder(2.5, 5); //简写</span><br></pre></td></tr></table></figure>

<p>使用情况:</p>
<ol>
<li>对一个对象只需要进行一次方法调用</li>
<li>匿名对象作为实参传递给一个方法调用</li>
</ol>
<h2 id="4-6-类的私有成员和公共成员"><a href="#4-6-类的私有成员和公共成员" class="headerlink" title="4.6 类的私有成员和公共成员"></a>4.6 类的私有成员和公共成员</h2><h3 id="4-6-1-私有成员"><a href="#4-6-1-私有成员" class="headerlink" title="4.6.1 私有成员"></a>4.6.1 私有成员</h3><p>在类的成员声明前加上私有成员访问控制修饰符<code>private</code>，则无法从该类的外部访问到类内部的成员，而只能被该类自身访问和修改，而不能被任何其他类，包括该类的子类来获取或引用，因此达到对数据最高级别保护的目的。</p>
<p>前文例子中的<code>volu.radius = 2.8;</code>和<code>volu.height = 5;</code>将造成编译错误</p>
<h3 id="4-6-2-公共成员"><a href="#4-6-2-公共成员" class="headerlink" title="4.6.2 公共成员"></a>4.6.2 公共成员</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class CylinderNew</span><br><span class="line">&#123;</span><br><span class="line">    private double radius;</span><br><span class="line">    private double height;</span><br><span class="line">    private double PI = 3.14;</span><br><span class="line"></span><br><span class="line">    public void setCylinder(double r, double h) &#123;</span><br><span class="line">        if (r &gt; 0 &amp;&amp; h &gt; 0) &#123;</span><br><span class="line">            radius = r;</span><br><span class="line">            height = h;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;你的数据有误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    double area()</span><br><span class="line">    &#123;</span><br><span class="line">        return PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">    double volume()</span><br><span class="line">    &#123;</span><br><span class="line">        return area() * height;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public class Example4_6_2</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        CylinderNew volu = new CylinderNew();</span><br><span class="line">        volu.setCylinder(-2.5, -5);</span><br><span class="line">        System.out.println(&quot;圆柱底面积： &quot; + volu.area());</span><br><span class="line">        System.out.println(&quot;圆柱体积： &quot; + volu.volume());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过公共方法<code>setCylinder()</code>来修改私有成员，并加入判断代码来杜绝错误数据的输入。</p>
<h2 id="4-7-方法的重载"><a href="#4-7-方法的重载" class="headerlink" title="4.7 方法的重载"></a>4.7 方法的重载</h2><p>方法的重载(Overloading)是实现”多态”的一种方法。重载是指同一个类内具有相同名称的多个方法，这些方法如果参数个数不同，或参数个数相同但类型不同，则这些同名的方法就具有不同的功能。</p>
<p>注意：Java语言中不允许参数个数或参数类型完全相同，而只有返回值类型不同的重载。</p>
<h2 id="4-8-构造方法"><a href="#4-8-构造方法" class="headerlink" title="4.8 构造方法"></a>4.8 构造方法</h2><h3 id="4-8-1-构造方法的定义和作用"><a href="#4-8-1-构造方法的定义和作用" class="headerlink" title="4.8.1 构造方法的定义和作用"></a>4.8.1 构造方法的定义和作用</h3><ul>
<li>构造方法(constructor)是一种特殊的方法，它是在对象被创建时初始化对象的成员的方法</li>
<li>构造方法的名称必须与它所在的类名完全相同</li>
<li>构造方法没有返回值，但构造方法名前不能使用<code>void</code>修饰符，因为一个类的构造方法的返回值类型就是该类本身</li>
<li>如果使用了<code>void</code>修饰符，就不再是构造方法而变成普通的方法了，无法自动调用</li>
<li>构造方法会在对象产生时自动执行，不需要在程序中调用</li>
<li>如果省略构造方法，Java编译器会自动生成一个默认的构造方法。当用户为该类自定义了构造方式后，将把系统默认提供的构造方法给覆盖(Overriding)</li>
<li>一般情况下，类都有一个或多个重载方法，通过重载，可以让用户用不同的参数来构造对象</li>
<li>Java语言允许在类内通过关键字<code>this</code>从某一个构造方法内调用另一个构造方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import com.sun.corba.se.impl.interceptors.PICurrent;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by tpwy on 7/9/17.</span><br><span class="line"> */</span><br><span class="line">class Cylinder</span><br><span class="line">&#123;</span><br><span class="line">    private double radius;</span><br><span class="line">    private  double height;</span><br><span class="line">    private double PI = 3.14;</span><br><span class="line">    private String color;</span><br><span class="line">    public Cylinder()</span><br><span class="line">    &#123;</span><br><span class="line">        this(2.5, 5, &quot;红色&quot;); //实现从一个构造方法到另一个构造方法</span><br><span class="line">        System.out.println(&quot;无参数被调用&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Cylinder(double r, double h, String str)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;有参数方法被调用&quot;);</span><br><span class="line">        radius = r;</span><br><span class="line">        height = h;</span><br><span class="line">        color = str;</span><br><span class="line">    &#125;</span><br><span class="line">    public void show()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;圆柱底半径：&quot; + radius);</span><br><span class="line">        System.out.println(&quot;圆柱高：&quot; + height);</span><br><span class="line">        System.out.println(&quot;颜色为：&quot; + color);</span><br><span class="line">    &#125;</span><br><span class="line">    double area()</span><br><span class="line">    &#123;</span><br><span class="line">        return PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">    double volume()</span><br><span class="line">    &#123;</span><br><span class="line">        return area() * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Example4_6_2</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Cylinder volu = new Cylinder();</span><br><span class="line">        System.out.println(&quot;圆柱底面积： &quot; + volu.area());</span><br><span class="line">        System.out.println(&quot;圆柱体积： &quot; + volu.volume());</span><br><span class="line">        volu.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<code>this</code>关键字必须写在构建方法内的第一行位置</p>
<ul>
<li>构造方法一般都是公有(public)的，因为它们在创建对象时，是在类的外部被系统自动调用的</li>
<li>构造方法被声明为<code>private</code>时，则无法在该构造方法所在的类以外的地方被调用，只能在类的内部调用。</li>
</ul>
<h2 id="4-9-静态成员"><a href="#4-9-静态成员" class="headerlink" title="4.9 静态成员"></a>4.9 静态成员</h2><p>被<code>static</code>修饰的成员称为静态成员，也称类成员；而不用<code>static</code>修饰的成员称为实例成员</p>
<h3 id="4-9-1-实例成员"><a href="#4-9-1-实例成员" class="headerlink" title="4.9.1 实例成员"></a>4.9.1 实例成员</h3><ul>
<li>当我们用<code>new</code>运算符产生两个不同的对象时候，这两个对象都各自拥有自己保存自己成员的存储空间，而不与其他对象共享。</li>
<li>两个对象的成员变量各自独立，且存于不同的内存之中。这样的成员变量在Java中称为实例变量</li>
<li>必须先创建对象，再利用对象来调用方法。这样的方法在Java中称为实例方法</li>
</ul>
<h3 id="4-9-2-静态变量"><a href="#4-9-2-静态变量" class="headerlink" title="4.9.2 静态变量"></a>4.9.2 静态变量</h3><ul>
<li>静态变量是隶属于类的变量，而不是属于任何一个类的具体对象。</li>
<li>静态变量是一个公共的存储单元，类的任意一个对象访问它时取得的都是同一个相同的数值</li>
<li>静态变量在某种程度上与其他语言的全局变量相似，如果不是私有的就可以在类的外部进行访问，此时不需要创建类的实例对象，只需要类名就可以引用</li>
<li>类中若含有静态变量，静态变量必须独立于方法之外</li>
<li>对于静态变量的使用，推荐采用<code>类名.静态变量名</code>的形式访问</li>
</ul>
<h3 id="4-9-3-静态方法"><a href="#4-9-3-静态方法" class="headerlink" title="4.9.3 静态方法"></a>4.9.3 静态方法</h3><p>一个方法声明为<code>static</code>有以下几重含义：</p>
<ol>
<li>非<code>static</code>的方法是属于某个对象的方法，对象的方法在内存中有专属于自己专用的代码段。而<code>static</code>的方法是属于整个类的，它在内存的代码段将被所有的对象所共用</li>
<li><code>static</code>方法不能操纵和处理属于某个对象的成员，而只能处理属于整个类的成员，即<code>static</code>方法只能访问<code>static</code>成员变量或调用<code>static</code>成员方法。</li>
<li>在静态方法中不能使用<code>this</code>或<code>super</code>，因为<code>this</code>代表调用该方法的对象，而静态方法不需要对象来调用，<code>this</code>也不应存在与”静态方法”内部</li>
<li>可以直接用类名来调用静态方法</li>
</ol>
<p>如果一个类在被Java虚拟机解释器装载运行时，由于Java程序是从<code>main()</code>方法开始运行的，因此类中必须有<code>main()</code>方法。由于Java虚拟机需要在类外调用<code>main()</code>方法，所有该方法的访问权限必然是<code>public</code>，又Java虚拟机运行时系统在开始执行一个程序前，并没有创建<code>main()</code>方法所在类的一个实例对象，因此只能通过类名来调用<code>main()</code>方法来作为程序的入口，所有方法必须是<code>static</code></p>
<h3 id="4-9-4-静态初始化器"><a href="#4-9-4-静态初始化器" class="headerlink" title="4.9.4 静态初始化器"></a>4.9.4 静态初始化器</h3><p>静态初始化器是由关键字<code>static</code>修饰的一对大括号”{}”括起来的语句组，作用与类的构造方法相似，都用于初始化工作。</p>
<p>与构造方法的不同：</p>
<ol>
<li>构造方法是对每个新创建的对象初始化，静态初始化器是对类本身进行初始化</li>
<li>构造方法用<code>new</code>运算符创建新对象时由系统自动执行，而静态初始化器一般不能由程序调用，他是在所属的类被加载入内存时由系统调用执行的</li>
<li>用<code>new</code>运算符创建多少个对象，构造方法就调用多少次，但静态初始化器则在类被加载入内存的时候只执行一次，与创建多少个对象无关</li>
<li>不同于构造方法，静态初始化器不是方法，没有文件名、返回值和参数</li>
</ol>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static </span><br><span class="line">&#123;</span><br><span class="line">    num = 100;</span><br><span class="line">    System.out.println(&quot;静态初始化器被调用了，num的除值为&quot; + num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类是在第一次被使用时候才被装载的，而不是在程序启动的时候。</p>
<h3 id="4-10-对象的应用"><a href="#4-10-对象的应用" class="headerlink" title="4.10 对象的应用"></a>4.10 对象的应用</h3><ol>
<li>类类型的变量属于非基本类型的变量</li>
<li>实际上对象是一种引用型的变量，而引用型变量实际上保存的是对象在内存中的首地址。是”指向对象的变量”</li>
</ol>
<h4 id="4-10-1-对象的赋值与比较"><a href="#4-10-1-对象的赋值与比较" class="headerlink" title="4.10.1 对象的赋值与比较"></a>4.10.1 对象的赋值与比较</h4><p><strong>当参数是基本数据类型时，则是传值方式调用；当参数是引用变量是，则是传址方式调用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Cylinder</span><br><span class="line">&#123;</span><br><span class="line">    private static final double PI = 3.14;</span><br><span class="line">    private double radius;</span><br><span class="line">    private int height;</span><br><span class="line">    public Cylinder(double r, int h)</span><br><span class="line">    &#123;</span><br><span class="line">        radius = r;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line">    public void compare(Cylinder volu)</span><br><span class="line">    &#123;</span><br><span class="line">        if (this == volu)</span><br><span class="line">            System.out.println(&quot;这两个对象相等&quot;);</span><br><span class="line">        else</span><br><span class="line">            System.out.println(&quot;这两个对象不相等&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Example</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Cylinder volu1 = new Cylinder(1.0, 2);</span><br><span class="line">        Cylinder volu2 = new Cylinder(1.0, 2);</span><br><span class="line">        Cylinder volu3 = volu1; // volu3和volu1指向同一对象</span><br><span class="line">        volu1.compare(volu2); //volu1和volu2尽管数值相同，在内存上是占据不同内存空间的互相独立的不同对象</span><br><span class="line">        volu1.compare(volu3); //他们的值是同一对象在内存的首地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-10-2-引用变量作为方法的返回值"><a href="#4-10-2-引用变量作为方法的返回值" class="headerlink" title="4.10.2 引用变量作为方法的返回值"></a>4.10.2 引用变量作为方法的返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Person(String name, int age)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name  = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public Person compare(Person p)</span><br><span class="line">    &#123;</span><br><span class="line">        if (this.age &gt; p.age)</span><br><span class="line">            return this;</span><br><span class="line">        else</span><br><span class="line">            return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Example4_10_2</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Person per1 = new Person(&quot;李三&quot;, 20);</span><br><span class="line">        Person per2 = new Person(&quot;张四&quot;, 21);</span><br><span class="line">        Person per3;</span><br><span class="line">        per3 = per1.compare(per2);</span><br><span class="line">        if (per3 == per1)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;李三年纪大&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;张四年纪大&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-10-3-类类型的数组"><a href="#4-10-3-类类型的数组" class="headerlink" title="4.10.3 类类型的数组"></a>4.10.3 类类型的数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Person(String name, int age)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name  = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void show()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;姓名：&quot; + name + &quot;\t年龄：&quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Example4_10_2</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Person[] per;</span><br><span class="line">        per = new Person[3];</span><br><span class="line">        per[0] = new Person(&quot;大傻&quot;,21);</span><br><span class="line">        per[1] = new Person(&quot;二傻&quot;,19);</span><br><span class="line">        per[2] = new Person(&quot;三傻&quot;,20);</span><br><span class="line">        per[1].show();</span><br><span class="line">        per[0].show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-10-4-以对象数组为参数进行方法调用"><a href="#4-10-4-以对象数组为参数进行方法调用" class="headerlink" title="4.10.4 以对象数组为参数进行方法调用"></a>4.10.4 以对象数组为参数进行方法调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Person(String name, int age)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name  = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int minAge(Person[] p)</span><br><span class="line">    &#123;</span><br><span class="line">        int min = Integer.MAX_VALUE;</span><br><span class="line">        for (int i=0; i&lt;p.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (p[i].age &lt; min)</span><br><span class="line">                min = p[i].age;</span><br><span class="line">        &#125;</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Example4_10_2</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Person[] per;</span><br><span class="line">        per = new Person[3];</span><br><span class="line">        per[0] = new Person(&quot;大傻&quot;,21);</span><br><span class="line">        per[1] = new Person(&quot;二傻&quot;,19);</span><br><span class="line">        per[2] = new Person(&quot;三傻&quot;,20);</span><br><span class="line">        System.out.println(&quot;最小的年纪是&quot; + Person.minAge(per));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的<code>minAge()</code>方法被声明为<code>static</code>，可以直接使用类名在调用该方法。</p>
<h1 id="常用的包和类"><a href="#常用的包和类" class="headerlink" title="常用的包和类"></a>常用的包和类</h1><h2 id="1-Java语言中的常用包"><a href="#1-Java语言中的常用包" class="headerlink" title="1.Java语言中的常用包"></a>1.Java语言中的常用包</h2><p>Java提供的用于语言开发的类库，称为应用程序编程接口(API-Application Programming Interface)，分别放在不同的包中</p>
<p>Java语言的常用包有：</p>
<ul>
<li>java.lang——语言包</li>
<li>java.io——输入输出流的文件包</li>
<li>java.awt——抽象窗口工具包</li>
<li>javax.swing——轻型组件工具包</li>
<li>java.util——实用包</li>
<li>javax.swing.JApplet——小程序包</li>
<li>java.net——网络功能包</li>
<li>java.sql——数据库连接包</li>
<li>java.text——文本包</li>
</ul>
<h3 id="1-1-语言包"><a href="#1-1-语言包" class="headerlink" title="1.1 语言包"></a>1.1 语言包</h3><p>java.lang提供了Java语言最基础的类，每个Java程序运行时系统都会自动引入这个包，所以该包的加载是默认的。</p>
<ul>
<li>Object</li>
<li>The Date Type Wrapper——数据类型包装类</li>
<li>String——字符串类</li>
<li>Math——数学类</li>
<li>System、Runtime——系统和运行时类</li>
<li>Class——类操作类</li>
<li>Throwable、Exception、Error——错误和异常处理类</li>
<li>Thread——线程类</li>
<li>Process——过程类</li>
</ul>
<h3 id="1-2-输入输出流的文件包"><a href="#1-2-输入输出流的文件包" class="headerlink" title="1.2 输入输出流的文件包"></a>1.2 输入输出流的文件包</h3><p>java.io是Java语言的标准输入、输出类库，包含了实现Java程序与操作系统、用户界面以及其他Java程序之间数据交换所需要的类</p>
<ul>
<li>基本输入/输出类</li>
<li>文件输入/输出类</li>
<li>过滤输入/输出类</li>
<li>管道输入/输出类</li>
<li>随机输入/输出类</li>
</ul>
<h3 id="1-3-抽象窗口工具包"><a href="#1-3-抽象窗口工具包" class="headerlink" title="1.3 抽象窗口工具包"></a>1.3 抽象窗口工具包</h3><p>java.awt是Java语言中用来构建图形用户界面(GUI)的类库，它包含许多界面元素和资源</p>
<p>该包主要从三个方面提供界面设计支持：低级绘图操作、图形界面组件和布局管理、界面用户交互控制和时间响应</p>
<ul>
<li>绘图类(Graphics)</li>
<li>各种控件类</li>
<li>布局管理类(LayoutManager)</li>
<li>事件类(event)</li>
</ul>
<h3 id="1-4-轻型组件工具包"><a href="#1-4-轻型组件工具包" class="headerlink" title="1.4 轻型组件工具包"></a>1.4 轻型组件工具包</h3><p>javax.swing是AWT工具包的扩展，Swing组件是纯Java编写的，不直接使用本地组件。javax.swing包主要有组件类、事件类、接口、布局类、菜单类等，为了区别Swing组件类和AWT组件类，Swing组件类的名字开头都有前缀”J”</p>
<ul>
<li>组件类(JComponent)</li>
<li>布局管理类</li>
</ul>
<h3 id="1-5-使用包"><a href="#1-5-使用包" class="headerlink" title="1.5 使用包"></a>1.5 使用包</h3><p>java.util提供了实现各种不同使用功能的类</p>
<ul>
<li>Scanner——数据输入类</li>
<li>Date、Calendar——日期类</li>
<li>LinkedList——链表类</li>
<li>Vector——向量类</li>
<li>Hashtable——哈希表类</li>
<li>Stack——栈类</li>
<li>TreeSet——树类</li>
</ul>
<h3 id="1-6-小程序包"><a href="#1-6-小程序包" class="headerlink" title="1.6 小程序包"></a>1.6 小程序包</h3><p>java.applet是用来实现运行与Internet浏览器中的Java Applet的工具类库</p>
<p>javax.swing.JApplet继承java.applet.Applet类</p>
<h3 id="1-7-网络功能包"><a href="#1-7-网络功能包" class="headerlink" title="1.7 网络功能包"></a>1.7 网络功能包</h3><p>java.net是Java语言用来实现网络功能的类库。目前已经实现的网络功能主要有:底层的网络通信、访问Internet资源。</p>
<ul>
<li>URL——访问网络资源类</li>
<li>Socket——套接字类</li>
<li>ServerSocket——服务器套接字类</li>
<li>DatagramPacket——数据报打包类</li>
<li>DatagramScoket——数据报通信类</li>
</ul>
<h3 id="1-8-数据库连接包"><a href="#1-8-数据库连接包" class="headerlink" title="1.8 数据库连接包"></a>1.8 数据库连接包</h3><p>java.sql是实现JDBC(Java DataBase Connection, Java 数据库连接)的类库。只有安装了合适的驱动程序，同一个Java程序不需修改就可以访问不同数据库的数据</p>
<h3 id="1-9-文本包"><a href="#1-9-文本包" class="headerlink" title="1.9 文本包"></a>1.9 文本包</h3><p>java.text中的<code>Format、DataFormat、SimpleDateFormat</code>等类提供各种文本或日期格式</p>
<h2 id="2-Java语言中的常用类"><a href="#2-Java语言中的常用类" class="headerlink" title="2.Java语言中的常用类"></a>2.Java语言中的常用类</h2><h3 id="2-1-Date-类"><a href="#2-1-Date-类" class="headerlink" title="2.1 Date 类"></a>2.1 Date 类</h3><p><code>Date</code>类在java.util包中，是描述日期时间的类。</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Date()</td>
<td>用系统日期时间创建Date对象</td>
</tr>
<tr>
<td>public Date(long date)</td>
<td>从1970年一月一日00:00:00开始到该日期时刻的微秒数</td>
</tr>
</tbody></table>
<p>| 方法 | 功能说明 |<br>| public long getTime() | 返回微秒数 |<br>| public boolean after(Date when) | 日期比较 |<br>| public boolean before(Date when) | 日期比较 |</p>
<p><code>Date</code>对象表示时间的默认顺序是 星期、月、日、小时、分、秒、年。可以使用java.text.DateFormat类的子类<code>java.text.SimpleDateFormat</code>来实现日期的格式化。</p>
<p><code>SimpleDateFormat(String pattern)</code>是一个常用的构造方法，该构造方法可以用参数<code>pattern</code>制定格式创建一个对象，该对象调用<code>format(Date date)</code>方法来简化时间对象<code>Date</code>。</p>
<p><code>pattern</code>中的有效字符序列：</p>
<ul>
<li>y或yy表示用2位数字输出的年份，yyyy表示用4位数字输出年份</li>
<li>M或MM表示用2位数字或文本输出月份，汉字输出的话需要包含至少3个M</li>
<li>d或dd表示用2位数字输出日</li>
<li>H或HH表示用2位数字输出小时</li>
<li>m或mm表示用2位数字输出分</li>
<li>s或ss表示用2位数字输出秒</li>
<li>E表示用字符创输出星期</li>
<li>a表示输出上、下午</li>
</ul>
<h3 id="2-2-Calendar类"><a href="#2-2-Calendar类" class="headerlink" title="2.2 Calendar类"></a>2.2 Calendar类</h3><p><code>Calendar</code>类在java.util包中，是描述日期时间的抽象类，通常用于将日期值分解。</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>public static final int YEAR</td>
<td>表示对象日期的年</td>
</tr>
<tr>
<td>public static final int MONTH</td>
<td>表示对象日期的月，0<del>11表示1</del>12月</td>
</tr>
<tr>
<td>public static final int DAY_OF_MONTH</td>
<td>表示对象日期的日</td>
</tr>
<tr>
<td>public static final int DATE</td>
<td>表示对象日期的日</td>
</tr>
<tr>
<td>public static final int DAY_OF_YEAR</td>
<td>表示对象日期在该年的第几天</td>
</tr>
<tr>
<td>public static final int WEEK_OF_YEAR</td>
<td>表示对象日期在该年的第几周</td>
</tr>
<tr>
<td>public static final int HOUR</td>
<td>表示对象日期的时</td>
</tr>
<tr>
<td>public static final int MINUTE</td>
<td>表示对象日期的分</td>
</tr>
<tr>
<td>public static final int SECOND</td>
<td>表示对象日期的秒</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int get(int field)</td>
<td>返回对象属性的field值，属性是上表描述的静态常量</td>
</tr>
<tr>
<td>public void set(int field, int value)</td>
<td>设置对象属性的field值</td>
</tr>
<tr>
<td>public boolean after(Object when)</td>
<td>同上</td>
</tr>
<tr>
<td>public boolean before(Object when)</td>
<td>同上</td>
</tr>
<tr>
<td>public static Canlendar getInstance()</td>
<td>获取Calendar对象</td>
</tr>
<tr>
<td>public final Date getTIme()</td>
<td>由Calendar对象创建Date对象</td>
</tr>
<tr>
<td>public long getTimeinMillis()</td>
<td>返回微秒数</td>
</tr>
<tr>
<td>public void setTimeInMillis(long millis)</td>
<td>类似与上行</td>
</tr>
</tbody></table>
<p>Calendar类对象一般不采用<code>new</code>运算符创建，而是通过该类的<code>getInstance()</code>方法创建并得到当前系统时间。</p>
<h3 id="2-3-Random类"><a href="#2-3-Random类" class="headerlink" title="2.3 Random类"></a>2.3 Random类</h3><p>Random类在java.util包中，模拟了一个伪随机数发生器</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Random()</td>
<td>用系统时间作为种子创建Random对象</td>
</tr>
<tr>
<td>public Random(long seed)</td>
<td>用seed作为种子创建Random对象</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int nextInt()</td>
<td>返回一个整型随机数</td>
</tr>
<tr>
<td>public int nextInt(int n)</td>
<td>返回一个大小在0～n之间的整型随机数</td>
</tr>
<tr>
<td>public long nextLong()</td>
<td>返回一个长整型随机数</td>
</tr>
<tr>
<td>public double nextDouble()</td>
<td>返回一个0.0~1.0之间的双精度随机数</td>
</tr>
</tbody></table>
<h3 id="2-4-Math类"><a href="#2-4-Math类" class="headerlink" title="2.4 Math类"></a>2.4 Math类</h3><p>Math类在java.util包中，提供了两个常量e和π，以及大量用于计算的基本数学函数。</p>
<h1 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h1><h2 id="5-1-类、超类、子类"><a href="#5-1-类、超类、子类" class="headerlink" title="5.1 类、超类、子类"></a>5.1 类、超类、子类</h2><ul>
<li>Java不支持多重继承，所以一个类只能有一个直接父类</li>
<li>Java语言中有一个名为<code>java.lang.Object</code>的特殊类，所有的类都是直接或间接地继承该类而得到的</li>
</ul>
<h3 id="5-1-1-定义子类"><a href="#5-1-1-定义子类" class="headerlink" title="5.1.1 定义子类"></a>5.1.1 定义子类</h3><p>用关键字<code>extends</code>表示继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class subclass extends superclass</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++注释：</p>
<p>Java和定义继承类的方式十分相似，Java用关键字<code>extends</code>代替C++中的冒号<code>:</code>。在Java中，所有的继承都是公有继承，而没有C++中的私有继承和保护继承</p>
<p>关键字<code>extends</code>表明正在构造的新类派生于一个已存在的类</p>
<ul>
<li>以存在的类称为<strong>超类(superclass)</strong>、基类(base class)或父类(parent class)。</li>
<li>新类称为<strong>子类(subclass)</strong>、派生类(derived class)或孩子类(child class)。</li>
</ul>
<p>在通过扩展垂泪定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中。</p>
<h3 id="5-1-2-覆盖方法"><a href="#5-1-2-覆盖方法" class="headerlink" title="5.1.2 覆盖方法"></a>5.1.2 覆盖方法</h3><p>当超类中的方法不适用于子类时，我们需要提供一个新方法来覆盖(override)超类中的这个方法</p>
<ul>
<li>问题：子类不能继承父类中的私有成员，因此也不能直接访问父类的私有成员</li>
<li>解决1：通过<code>super</code>关键字来调用父类中的访问器或者私有成员本身(推荐)</li>
<li>解决2：也可以将父类中的成员声明为<code>protected</code>，<code>protected</code>成员可以被三种类引用：类自身、与它在同一个包中的其他类，和其他包中该类的子类。（违反OOP提倡的数据封装原则，安全性比C++差，需谨慎使用）</li>
<li>子类不能覆盖父类中声明为<code>final</code>或<code>static</code>的方法</li>
<li>子类中不能删除继承的任何域和方法</li>
<li><code>super</code>与<code>this</code>不同，不是一个对象的引用，不能将<code>super</code>赋给另一个对象变量。</li>
</ul>
<p>C++ 注释：</p>
<p>在Java中使用关键字<code>super</code>调用超类中的方法，在C++中则采用超类名加上<code>::</code>操作符的形式</p>
<h3 id="5-1-3-子类构造器"><a href="#5-1-3-子类构造器" class="headerlink" title="5.1.3 子类构造器"></a>5.1.3 子类构造器</h3><p>由于子类不能访问超类中的私有域，所有使用<code>super()</code>调用父类的构造器，对这部分私有域进行初始化</p>
<ul>
<li>如果子类的构造器没有显式地调用超类的构造器，则自动调用超类默认(没有参数)的构造器。</li>
<li>如果超类中没有不带参数的构造器，子类构造器又不显式地调用超类的其他构造器，则Java编译器将报错</li>
<li>为了避免编译器报错，必须在父类中定义一个没有参数的构造器</li>
<li>与<code>this()</code>相同，<code>super()</code>语句必须放在子类构造器方法的第一行，因此<code>this()</code>和<code>super()</code>不能同时存在于一个构造器方法中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    public Person()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;调用了Person类的无参数构造器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String name, int age)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        System.out.println(&quot;调用了Person类的有参数构造器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    protected void show()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;姓名： &quot; + name + &quot;\t年纪：　&quot; + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person</span><br><span class="line">&#123;</span><br><span class="line">    private String department;</span><br><span class="line">    int age = 25;</span><br><span class="line">    public Student(String name, int age, String department)</span><br><span class="line">    &#123;</span><br><span class="line">        super(name, age);</span><br><span class="line">        this.department = department;</span><br><span class="line">        super.show();</span><br><span class="line">        System.out.println(&quot;系别: &quot; + department);</span><br><span class="line">    &#125;</span><br><span class="line">    public Student()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;调用子类中的无参数构造器&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StudentTest &#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Student stu = new Student(&quot;Nancy&quot;, 30, &quot;information&quot;);</span><br><span class="line">        System.out.println();</span><br><span class="line">        Student ste = new Student();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出结果</span><br><span class="line"></span><br><span class="line">调用了Person类的有参数构造器</span><br><span class="line">姓名： Nancy	年纪：　30</span><br><span class="line">系别: information</span><br><span class="line"></span><br><span class="line">调用了Person类的无参数构造器</span><br><span class="line">调用子类中的无参数构造器</span><br></pre></td></tr></table></figure>

<h3 id="5-1-4-多态"><a href="#5-1-4-多态" class="headerlink" title="5.1.4 多态"></a>5.1.4 多态</h3><p>有一种用来判断是否应该设计为继承关系的简单规则，就是”is-a”规则，它的另一种表述发是置换法则，表明程序中出现超类对象的任何地方都可以用子类对象置换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person e;</span><br><span class="line">e = new Person(...);</span><br><span class="line"></span><br><span class="line">e = new Student(...);</span><br><span class="line">// 我们可以通过这些方式用父类的对象访问子类的成员</span><br><span class="line">// 但这种访问只限于&quot;覆盖&quot;这种情况的发生，如果是方法仅存于子类，就无法访问</span><br></pre></td></tr></table></figure>

<p>在Java中，对象变量是多态的，一个<code>Person</code>变量既可以引用一个<code>Person</code>类对象，也可以引用<code>Person</code>类对象的任何一个子类的对象，如<code>Student</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student nancy = new Student(...);</span><br><span class="line">Person[] man = new person[3];</span><br><span class="line">person[0] = nancy; //变量person[0]和nancy引用同一个对象，但是编译器将person[0]看成Person对象</span><br><span class="line">Student m = Person[1]; //Error</span><br></pre></td></tr></table></figure>

<h3 id="5-1-5-理解方法调用"><a href="#5-1-5-理解方法调用" class="headerlink" title="5.1.5 理解方法调用"></a>5.1.5 理解方法调用</h3><p>假设要调用<code>x.f(args)</code>，隐式参数ｘ声明为类Ｃ的一个对象。调用过程的详细描述：</p>
<ol>
<li>编译器查看对象的声明类和方法名。存在多个名为<code>f</code>的方法时，编译器将会一一列出所有C类和其超类中访问属性为<code>public</code>且名为<code>f</code>的方法</li>
<li>编译器将查看调用方法时提供的参数类型。重载解析：如果在所有名为<code>f</code>的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。如果编译器没有找到与参数类型匹配的方法，或者经过类型转换后有多个方法与之匹配，就会报告错误</li>
<li>如果是<code>private</code>、<code>static</code>、<code>final</code>方法或者构造器，编译器就可以准确知道应该调用哪个方法，即静态绑定(static binding)。以此相对应的，调用的方法依赖于隐式参数的实际类型，并且在运行中实现动态绑定。</li>
<li>当程序运行时，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最适合的那个类的方法 </li>
</ol>
<p>注意：</p>
<ol>
<li>返回类型不是签名中的一部分，所以在覆盖方法时一定要保证返回类型的兼容性</li>
<li>每次调用方法都会进行搜索，时间开销相当大。因此虚拟机预定为每个类创建了一个方法表(method table)，列出所有方法的签名和实际调用的方法。如果使用<code>super</code>关键字调用方法，编译器将对隐式参数超类的方法进行搜索</li>
<li>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性</li>
</ol>
<h3 id="5-1-6-阻止继承：final类和方法"><a href="#5-1-6-阻止继承：final类和方法" class="headerlink" title="5.1.6 阻止继承：final类和方法"></a>5.1.6 阻止继承：final类和方法</h3><ul>
<li><code>final</code>类不允许扩展，无法利用该类来定义子类</li>
<li><code>final</code>类所有的方法都自动称为<code>final</code>方法</li>
<li><code>final</code>方法不能被子类覆盖</li>
<li>声明为<code>final</code>的主要目的：确保它们不会再子类中改变语义</li>
<li>在C++和C#中，如果没有特别地说明，所有的方法都不具有多态性</li>
<li>如果一个方法被覆盖并且很短，编译器就能够对它进行优化处理，这个过程称为内联(inlining)</li>
</ul>
<h3 id="5-1-7-强制类型转换"><a href="#5-1-7-强制类型转换" class="headerlink" title="5.1.7 强制类型转换"></a>5.1.7 强制类型转换</h3><ul>
<li>进行强制类型转换的唯一原因：在暂时忽视对象的实际类型之后，使用对象的全部功能</li>
<li>如果试图在继承链上进行向下的类型转换，并”谎报”有关对象包含的内容，那么运行程序时系统将报告这个错误；如果没有捕获到这个异常，程序将中止</li>
<li>在进行类型转换之前，应先用<code>instanceof</code>方法检查是否能够成功转换</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (person[1] instanceof Student)</span><br><span class="line">&#123;</span><br><span class="line">    nancy = (Student) person[1];</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果x为<code>null</code>，进行检查不会产生异常，只是返回false。因为<code>null</code>没有引用任何对象</li>
<li>不推荐使用类型转换和<code>instanceof</code>运算符</li>
</ul>
<p>C++注释：</p>
<p>当类型转换失败时，Java不会生成一个null对象 ，而是抛出一个异常。这种做法有点像C++中的引用(reference)转换。</p>
<h3 id="5-1-8-抽象类"><a href="#5-1-8-抽象类" class="headerlink" title="5.1.8 抽象类"></a>5.1.8 抽象类</h3><ul>
<li>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Person</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    ...</span><br><span class="line">    public abstract String getDescription();</span><br><span class="line">    </span><br><span class="line">    public Person(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName()</span><br><span class="line">    &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>除了抽象方法，抽象类还可以包括具体数据和具体方法。建议尽量将通用的域和方法(不管是不是抽象的)放在超类(也不管是不是抽象的)</li>
<li>抽象方法充当着站位的角色，它的具体实现在子类中。</li>
<li>扩展抽象类有两个选择：<ol>
<li>在抽象类中定义部分抽象类方法或不定义抽象类放在，这样就必须将子类也标记为抽象类</li>
<li>定义全部的抽象方法，这样子类就不是抽象的了</li>
</ol>
</li>
<li>类即使不包含抽象方法，也可以声明为抽象类，但要注意抽象类不能被实例化。</li>
<li>可以定义一个抽象类的对象变量，但它只能引用非抽象子类的对象</li>
</ul>
<p>C++注释：</p>
<p>在C++中，有一种尾部用<code>=0</code>标记的抽象方法称为纯虚函数，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person // C++</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">        virtual string getDescription()=0;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只要有一个纯虚函数，这个类就是抽象类。在C++中没有表示抽象类的特殊关键字</p>
<h2 id="5-2-Object：所有类的超类"><a href="#5-2-Object：所有类的超类" class="headerlink" title="5.2 Object：所有类的超类"></a>5.2 Object：所有类的超类</h2><ul>
<li><code>Object</code>是Java中所有类的始祖，在Java中每个类都是由它扩展而来的。</li>
<li>如果没有明确地指出超类，Object就被认为是这个类的超类</li>
<li>使用<code>Object</code>类型的变量可以引用任何类型的变量</li>
<li>在Java中，只有基本类型变量不是对象</li>
<li>所有的数组类型，不论是对象数组还是基本类型的数组都扩展了<code>Object</code>类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj;</span><br><span class="line">Employee[] staff = new Employee[10];</span><br><span class="line">obj = staff;</span><br><span class="line">obj = new int[10];</span><br></pre></td></tr></table></figure>

<p>C++注释：在C++中没有所有类的根类，但每个指针都可以转换成<code>void*</code>指针</p>
<h3 id="5-2-1-equals-方法"><a href="#5-2-1-equals-方法" class="headerlink" title="5.2.1 equals 方法"></a>5.2.1 equals 方法</h3><ol>
<li><code>Object</code>类中的<code>equals</code>方法用于检测一个对象是否等于另一个对象</li>
<li><code>equals</code>方法将判断两个对象是否具有相同的引用</li>
<li><code>==</code>操作符判断两个变量的值，即它们的引用地址是否相同</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.time.*;</span><br><span class="line"></span><br><span class="line">class Employee</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    public boolean  equals(Object otherObject)</span><br><span class="line">    &#123;</span><br><span class="line">        if (this == otherObject)</span><br><span class="line">            return true;</span><br><span class="line">        if (otherObject == null)</span><br><span class="line">            return false;</span><br><span class="line">        if (getClass() != otherObject.getClass())</span><br><span class="line">            return false;</span><br><span class="line">        Employee other = (Employee) otherObject;</span><br><span class="line">        return name.equals(other.name)</span><br><span class="line">                &amp;&amp; salary == other.salary</span><br><span class="line">                &amp;&amp; hireDay.equals(other.hireDay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Manager extends Employee</span><br><span class="line">&#123;   </span><br><span class="line">    ...</span><br><span class="line">    public boolean eaquals(Object otherObject)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!super.equals(otherObject)) </span><br><span class="line">            return false;</span><br><span class="line">        Manager other = (Manager) otherObject;</span><br><span class="line">        return this.bonus == other.bonus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子类中定义<code>equals</code>方法时，首先调用超类的<code>equals</code>。如果检测失败，对象就不可能相等，如果超类中的域都相等，则比较子类的实例域</p>
<h3 id="5-2-2-相等测试与继承"><a href="#5-2-2-相等测试与继承" class="headerlink" title="5.2.2 相等测试与继承"></a>5.2.2 相等测试与继承</h3><p>如果隐式和显式的参数不属于同一个类，<code>equals</code>方法将如何处理?</p>
<ul>
<li>不建议使用<code>instanceof</code>进行检测。</li>
<li>Java语言要求<code>equals</code>方法具有以下特性：<ol>
<li>自反性：任何非空引用<code>x</code>,<code>x.equals(x)</code>应该返回<code>true</code></li>
<li>对称性：对于任何引用<code>x</code>和<code>y</code>，当且仅当<code>x.equals(y)</code>返回<code>true</code>，<code>y.equals(x)</code>也应该返回<code>true</code></li>
<li>传递性：对于任何引用<code>x</code>、<code>y</code>和<code>z</code>，如果<code>x.equals(y)</code>返回<code>true</code>，<code>y.equals(z)</code>返回<code>true</code>，<code>x.equals(x)</code>也返回<code>true</code></li>
<li>一致性：如果<code>x</code>和<code>y</code>引用的对象没有发生变化，反复调用<code>x.equals(y)</code>应该返回同样的结果</li>
<li>对于任何非空引用<code>x</code>，<code>x.equals(null)</code>应该返回<code>null</code></li>
</ol>
</li>
<li>编写完美的<code>equals</code>方法的建议：<ol>
<li>显示参数命名为<code>otherObject</code>，稍后需要将它转换成另一个叫做<code>other</code>的变量</li>
<li>检测<code>this</code>和<code>otherObject</code>是否引用同一个对象：<code>if (this == otherObject) return true;</code></li>
<li>检测<code>otherObject</code>是否为<code>null</code>，如果为<code>null</code>返回<code>false</code>：<code>if (otherObject == null) return false;</code></li>
<li>比较<code>this</code>和<code>otherObject</code>是否属于同一个类：<ul>
<li>如果<code>equals</code>的语义在每个子类中有所改变，就是用<code>getClass</code>方法来检测：<code>if (getClass() != otherObject.getClass()) return false;</code></li>
<li>如果所有的子类都拥有统一的语义，就是用<code>instanceof</code>检测，此时超类的<code>equals</code>方法应声明为<code>final</code>：<code>if(！(otherObject instanceOf ClassName)) return false;</code></li>
</ul>
</li>
<li>将<code>otherObject</code>转换为相应的类类型变量： <code>ClassName other = (ClassName) otherObject;</code></li>
<li>现在开始对所有需要比较的域进行比较。使用<code>==</code>比较基本类型域，使用<code>equals</code>比较对象域。如果所有的域都匹配则返回<code>true</code>，否则返回<code>false</code></li>
</ol>
</li>
<li>如果在子类中重新定义<code>equals</code>，其中需要调用`super.equals(other)</li>
<li>对于数组类型的域，可以使用静态的<code>Arrays.equals</code>方法检测</li>
<li>为了避免发生参数类型错误，可以使用<code>@override</code>对覆盖超类的方法进行标记，如果发生错误，或正在定义一个新方法，编译器将给出错误报告。</li>
</ul>
<h3 id="5-2-3-hashCode-方法"><a href="#5-2-3-hashCode-方法" class="headerlink" title="5.2.3 hashCode　方法"></a>5.2.3 hashCode　方法</h3><ul>
<li>散列码(hash code)是由对象导出的一个整型值，散列码没有规律</li>
<li>由于<code>hashCode</code>方法定义在<code>Object</code>类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址</li>
<li>如果重新定义<code>equals</code>方法，就必须重新定义<code>hashCode</code>方法，以便用户可以将对象导入到散列表中</li>
<li><code>hashCode</code>方法应该返回一个整型数值，并合理地组合实例域的散列码，以便让各个不同的对象产生的散列码更加均匀</li>
<li><code>equals</code>与<code>hashCode</code>的定义必须一致：如果<code>x.equals(y)</code>返回<code>true</code>，那么<code>x.hashCode()</code>和<code>y.hashCode()</code>应该具有相同的值。例子：如果定义的<code>Employee.equals</code>比较雇员的ID，那么<code>hashCode</code>方法就只需要散列ID</li>
<li>可以使用<code>Arrays.hashCode</code>方法计算数组类型的散列码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Spring类使用下列算法计算散列码</span><br><span class="line"></span><br><span class="line">int hash = 0;</span><br><span class="line">for (int i = 0; i &lt; length(); i++)</span><br><span class="line">    hash = 31 * hash + charAt(i);</span><br><span class="line"></span><br><span class="line">// 推荐构建自定义类的hashCode方法</span><br><span class="line"></span><br><span class="line">public int hashCode()</span><br><span class="line">&#123;</span><br><span class="line">    return Object.hash(filed1, field2, field3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-4-toString-方法"><a href="#5-2-4-toString-方法" class="headerlink" title="5.2.4 toString 方法"></a>5.2.4 toString 方法</h3><ul>
<li><code>toString</code>方法用于返回表示对象值的字符串</li>
<li>随处可见<code>toString</code>的原因是：只要对象与一个字符串通过操作符<code>+</code>连接起来，Java编译就会自动调用<code>toString</code>方法获得对象的字符串描述</li>
<li><code>Object</code>类定义了<code>toString</code>方法用来打印输入对象所属的类名和散列码</li>
<li>用<code>&quot;&quot;+x</code>来替代<code>x.toString()</code>的好处是：如果x是基本类型也能照样执行</li>
<li>如果x是任意一个对象，并调用<code>System.out.println(x);</code>，那么<code>println()</code>将会自动调用<code>x.toString()</code>并打印输出的字符串</li>
<li>数组继承了<code>Object</code>类的<code>toString</code>方法，所以要想生成对象描述，需要使用静态方法<code>Arrays.toString()</code>，如果是多维数组的话则需要调用<code>Arrays.deepToString()</code>方法</li>
<li><code>toString</code>方法是一种非常有用的调试工具(不过不是最好的)</li>
<li>强烈建议自定义的每一个类增加<code>toString</code>方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// toString方法的推荐定义</span><br><span class="line">public String toString()</span><br><span class="line">&#123;</span><br><span class="line">    return getClass().getName() + &quot;[name= &quot; + name + &quot;, salary= &quot; + salary + &quot;, hireDay= &quot; + hireDay + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在子类中推荐</span><br><span class="line">public String toString()</span><br><span class="line">&#123;</span><br><span class="line">    return super.toString() + &quot;[bonus= &quot; + bonus + &quot;]&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-泛型数组列表"><a href="#5-3-泛型数组列表" class="headerlink" title="5.3 泛型数组列表"></a>5.3 泛型数组列表</h2><ul>
<li><code>ArrayList</code>类类似数组，但在添加和删除元素时可以自动调节数组容量和功能，而不需要为此编写任何代码</li>
<li><code>ArrayList</code>是一个采用类型参数(type parameter)的泛型类(generic class)。为了制定数组列表保存的元素对象类型，需要用一堆尖括号将类名括起来加在后面。</li>
<li>声明和构造一个数组列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;();</span><br><span class="line">//简写</span><br><span class="line">ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">//使用add方法</span><br><span class="line">//如果调用add且内部数组已经满了，数组列表将会自动地创建一个更大的数组并将所有的对象拷贝过去</span><br><span class="line">staff.add(new Employee(&quot;Harry&quot;,...)); </span><br><span class="line"></span><br><span class="line">//如果已经清楚或能够估计数组可能存储的元素数量，可以调用ensureCapacity方法</span><br><span class="line">staff.ensureCapacity(100); //将分配一个包含100个对象的内部数组，调用100次add不用重新分配空间</span><br><span class="line"></span><br><span class="line">//size方法返回数组列表中包含的实际元素数目</span><br><span class="line">staff.size(); //等价于数组的length方法</span><br><span class="line"></span><br><span class="line">/**一旦确认数组的大小不再发生变化，就可以调用trimToSize方法</span><br><span class="line"> *该方法将存储区域的大小调整为当前元素数量所需要的存储空间数目</span><br><span class="line"> *垃圾回收期将回收多余的存储空间</span><br><span class="line"> */</span><br><span class="line">staff.trimToSize();</span><br></pre></td></tr></table></figure>

<ul>
<li>数组列表的容量和数组大小有一个非常重要的区别：如果为数组分配100个元素的存储空间，数组就有100个空位置可供使用。而容量为100的数组列表只是拥有保存100个元素的潜力，但是最初甚至完成初始化构造前并不含有任何元素</li>
</ul>
<p>C++注释：</p>
<ol>
<li><code>ArrayList</code>类似于C++的<code>vector</code>模板，两者都是泛型类型。但<code>vector</code>模板为了便于访问元素重载了<code>[]</code>运算符，而Java没有运算符重载所有必须调用显式方法</li>
<li>C++向量是值拷贝，而在Java中赋值语句的操作是让两个变量都引用同一个数组列表</li>
</ol>
<h3 id="5-3-1-访问数组列表元素"><a href="#5-3-1-访问数组列表元素" class="headerlink" title="5.3.1 访问数组列表元素"></a>5.3.1 访问数组列表元素</h3><p>使用set方法设置第i个元素。注意只有i小于或等于数组列表的大小时才能调用，set方法只能替换数组已有元素，添加新元素还是使用add方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staff.set(i, harry);//等价于数组中的赋值 a[i] = harry;</span><br></pre></td></tr></table></figure>

<p>获得数组列表的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee m = staff.get(i); //等价于数组中的 Employee m = staff[i];</span><br></pre></td></tr></table></figure>

<p>在没有泛型类时，原始的<code>ArrayList</code>类提供的get方法只能返回<code>Object</code>，因此get方法的调用者必须对返回值进行类型转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee e = (Employee) staff.get(i);</span><br></pre></td></tr></table></figure>

<p>原始的ArrayList存在一定的危险性，因为add和set方法都允许接受任何类型的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">staff.set(i, &quot;Harry&quot;); //编译器不会给出警告</span><br><span class="line">staff&lt;Employee&gt;.set(i, &quot;Harry&quot;); //Error</span><br></pre></td></tr></table></figure>

<p>为了灵活扩展数组，又能方便访问数组元素，推荐使用以下技巧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;X&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">while(...)</span><br><span class="line">&#123;</span><br><span class="line">    x = ...;</span><br><span class="line">    list.add(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X[] a = new X[list.size()];</span><br><span class="line">list.toArray(a);</span><br></pre></td></tr></table></figure>

<p>使用带索引参数的add方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int n = staff.size() / 2;</span><br><span class="line">staff.add(n, e);</span><br></pre></td></tr></table></figure>

<p>删除元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X e = staff.remove(n);</span><br></pre></td></tr></table></figure>

<p>使用<code>for each</code>遍历数组列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (Employee e : staff)</span><br><span class="line">    do something with e</span><br><span class="line"></span><br><span class="line">// 等价于</span><br><span class="line"></span><br><span class="line">for (int i; i&lt;staff.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    Emplyee e = staff.get(i);</span><br><span class="line">    do something with e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-2-类型化与原始数组列表的兼容性"><a href="#5-3-2-类型化与原始数组列表的兼容性" class="headerlink" title="5.3.2 类型化与原始数组列表的兼容性"></a>5.3.2 类型化与原始数组列表的兼容性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class EmployeeeDB</span><br><span class="line">&#123;</span><br><span class="line">    public void update(ArrayList list) &#123;...&#125;</span><br><span class="line">    public ArrayList find(String query) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以将一个类型化的数组列表传递给<code>update</code>方法，而并不需要进行类型转换</li>
<li>尽管这样做不会报错或者警告，但这样调用并不安全</li>
<li>如果数组列表中的元素不是<code>Employee</code>类型，对这些元素进行检索时将发生异常</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff = ...;</span><br><span class="line">employeeDB.update(staff);</span><br></pre></td></tr></table></figure>

<p>相反的，将一个原始的<code>ArrayList</code>付给一个类型化的<code>ArrayList</code>会得到一个警告</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; result = employeeDB.find(query); //yield warning</span><br><span class="line"></span><br><span class="line">// 使用类型转换并不能避免问题</span><br><span class="line">ArrayList&lt;Employee&gt; result = (ArrayLIst&lt;Employee&gt;) employeeDB.find(query);</span><br></pre></td></tr></table></figure>

<p>鉴于兼容性的考虑，编译器在对类型转换进行检查后，如果没有发现违反规则的现象，就将所有的类型化数组列表转换为原始<code>ArrayList</code>对象。</p>
<p>一旦能确保不会发生严重后果，可以用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>标注来标记这个变量能够接受类型转换</p>
<h2 id="5-4-对象包装器和自动装箱"><a href="#5-4-对象包装器和自动装箱" class="headerlink" title="5.4 对象包装器和自动装箱"></a>5.4 对象包装器和自动装箱</h2><ul>
<li>有时需要将基本类型转换为对象。所有的基本类型都有一个与之相对应的类，这些类称为包装器(wrapper)。</li>
<li>例子：<code>Integer、Long、Double、Short、Byte、Character、Void和Boolean</code>，前六个类派生于公共的超类<code>Number</code></li>
<li>对象包装器类是不可变的，即一旦构造了包装器就不允许更改包装在其中的值。</li>
<li>对象包装器类还是<code>final</code>，因此不能定义它们的子类</li>
</ul>
<p>假设定义一个整型数组列表，而尖括号中的类型参数不允许是基本类型的时候，就需要使用对象包装器类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //由于效率非常低，只适合构造小型集合</span><br><span class="line"></span><br><span class="line">list.add(3); //将自动转换为list.add(Integer.valueOf(3));</span><br><span class="line">//这种变换被称为自动装箱(autoboxing)，也称自动打包(autowrapping)</span><br><span class="line"></span><br><span class="line">int n = list.get(i); // 将Integer对象赋给int值的时候将会自动拆箱</span><br><span class="line"></span><br><span class="line">Integer n = 3;</span><br><span class="line">n++; // 在算术表达式中也能自动的装箱拆箱</span><br></pre></td></tr></table></figure>

<p>大多数情况下，容易有一种假象，即基本类型和它们的对象包装器类是一样的，只是它们的相等性不同</p>
<p>自动装箱规范要求<code>boolean、byte、char &lt;= 127</code>,介于-128和127之间的<code>short</code>和<code>int</code>被包装在固定的对象中，所以会出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) </span><br><span class="line">&#123;</span><br><span class="line">    Integer a = 100;</span><br><span class="line">    Integer b = 100;</span><br><span class="line">    System.out.println(&quot;a==b: &quot; + (a==b));</span><br><span class="line">    System.out.println(&quot;a.equals(b)&quot; + a.equals(b));</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    Integer x = 1000;</span><br><span class="line">    Integer y = 1000;</span><br><span class="line">    System.out.println(&quot;x==y: &quot; + (x==y));</span><br><span class="line">    System.out.println(&quot;x.equals(y）&quot; + x.equals(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//output</span><br><span class="line">a==b: true</span><br><span class="line">a.equals(b)true</span><br><span class="line"></span><br><span class="line">x==y: false</span><br><span class="line">x.equals(y）true</span><br></pre></td></tr></table></figure>

<ul>
<li>为了避免<code>==</code>运算符的不确定的结果，我们调用<code>equals</code>方法来比较包装器对象</li>
<li>由于包装器类引用可以是<code>null</code>，所有自动装箱可能抛出<code>NullPointerException</code>异常</li>
<li>如果在一个条件表达式中混合使用<code>Integer</code>和<code>Double</code>类型，<code>Integer</code>值就会拆箱提升为<code>double</code>，再装箱为<code>Double</code></li>
<li>装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时插入必要的方法调用，而虚拟机只负责执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer n = 1;</span><br><span class="line">Double x = 2.0;</span><br><span class="line">System.out.println(true? n: x); //print 1.0</span><br></pre></td></tr></table></figure>

<p>由于Java方法都是按值传递的，因此不可能编写下面这样一个能够增加参数值的Java方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void triple(int x) //doesn&apos;t work</span><br><span class="line">&#123;</span><br><span class="line">    x = 3 * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 替换成Integer也不起作用，因为Integer对象是不可变的</span><br><span class="line"></span><br><span class="line">// 想要编写一个修改数值参数值的方法，就需要使用在org.omg.CORBA包中定义的持有者(holder)类型</span><br><span class="line">// 每个持有者类型都包括一个公有(!)域值可以访问存储在里面的值</span><br><span class="line"></span><br><span class="line">import org.omg.CORBA.IntHolder;</span><br><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        IntHolder t = new IntHolder(5);</span><br><span class="line">        triple(t);</span><br><span class="line">        System.out.println(t.value);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void triple(IntHolder x)</span><br><span class="line">    &#123;</span><br><span class="line">        x.value = 3 * x.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-5-参数数量可变的方法"><a href="#5-5-参数数量可变的方法" class="headerlink" title="5.5 参数数量可变的方法"></a>5.5 参数数量可变的方法</h2><p>现在的Java版本提供了可以用可变的参数数量调用的方法(有时称为”变参”方法)</p>
<p>举个变参方法的例子：<code>printf</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class PrintStream</span><br><span class="line">&#123;</span><br><span class="line">    public PrintStream printf(String fmt, Object... args) </span><br><span class="line">    &#123;</span><br><span class="line">        return format(fmt, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的省略号表明这个方法可以接收任意数量的对象(除fmt参数之外)。实际上<code>printf</code>方法只接收了两个参数：格式化字符串和<code>Object[]</code>数组(如果调用者提供的是基本类型的值，则自动装箱功能将它们转换为对象)。然后扫描<code>fmt</code>字符串，将第i个格式说明符和<code>arg[i]</code>的值匹配起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 用户也可以自己定义可变参数的方法</span><br><span class="line">public static double max(double...values)</span><br><span class="line">&#123;</span><br><span class="line">    double largest = Double.MIN_VALUE;</span><br><span class="line">    for (double v: values)</span><br><span class="line">    &#123;</span><br><span class="line">        if (v &gt; largest)</span><br><span class="line">            largest = v;</span><br><span class="line">    &#125;</span><br><span class="line">    return largest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-6-枚举类"><a href="#5-6-枚举类" class="headerlink" title="5.6 枚举类"></a>5.6 枚举类</h2><ul>
<li>比较枚举类的值时，永远不需要调用<code>equals</code>，而直接使用<code>==</code>就可以</li>
<li>如果需要的话，可以在枚举类型中添加一些构造器、方法和域。当然构造器只是在构造枚举常量的时候被调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 典型例子</span><br><span class="line">public enum Size &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;</span><br><span class="line"></span><br><span class="line">public enum Size</span><br><span class="line">&#123;</span><br><span class="line">    SMALL(&quot;S&quot;), MEDIUM(&quot;M&quot;), LARGE(&quot;L&quot;), EXTRA_LARGE(&quot;XL&quot;);</span><br><span class="line"></span><br><span class="line">    private String abbreviation;</span><br><span class="line"></span><br><span class="line">    private Size(String abbreviation)</span><br><span class="line">        this.abbreviation = abbreviation;</span><br><span class="line">    public String getAbbreviation()</span><br><span class="line">        return abbreviation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的枚举类型都是<code>Enum</code>类的子类</p>
<h2 id="5-7-反射"><a href="#5-7-反射" class="headerlink" title="5.7 反射"></a>5.7 反射</h2><ul>
<li>反射库(reflection library)提供了一个非常丰富且精心设计的工具集以便编写能够动态操纵Java代码的程序。</li>
<li>能够分析类能力的程序称为反射(reflective)。反射机制可以用来：<ol>
<li>在运行时分析类的能力</li>
<li>在运行是查看对象</li>
<li>实现通过的数组操作代码</li>
<li>利用<code>Method</code>对象，这个对象很像C++中的函数指针</li>
</ol>
</li>
<li>反射常用与工具构造而不是应用程序设计<br>（暂时跳过）</li>
</ul>
<h2 id="5-8-继承的设计技巧"><a href="#5-8-继承的设计技巧" class="headerlink" title="5.8 继承的设计技巧"></a>5.8 继承的设计技巧</h2><ol>
<li>将公共操作和与放在超类中</li>
<li>不要使用没有受保护的域。(protected适用于哪些不提供一般用途而在子类中重新定义的方法)</li>
<li>使用继承实现”is-a”关系</li>
<li>除非所有继承的方法都有意义，否则不要使用继承</li>
<li>在覆盖方法时不要改变预期的行为</li>
<li>使用多态而非类型信息</li>
<li>不要过多的使用反射</li>
</ol>
<h1 id="第六章-接口、lambda类与内部类"><a href="#第六章-接口、lambda类与内部类" class="headerlink" title="第六章 接口、lambda类与内部类"></a>第六章 接口、lambda类与内部类</h1><h2 id="6-1-接口"><a href="#6-1-接口" class="headerlink" title="6.1 接口"></a>6.1 接口</h2><h3 id="6-1-1-接口概念"><a href="#6-1-1-接口概念" class="headerlink" title="6.1.1 接口概念"></a>6.1.1 接口概念</h3><ul>
<li>在Java中，接口不是类，而是对类的一组描述，这些类要遵从接口描述的统一格式进行定义</li>
<li>接口的结构与抽象类非常相似，接口本身也具有数据成员和抽象方法，但它与抽象类有下列不同<ol>
<li>接口的数据成员都是静态且必须初始化</li>
<li>接口中的方法必须全部声明为<code>abstract</code></li>
</ol>
</li>
<li>接口中的所有方法自动地属于<code>public</code>，因此不必提供关键字<code>public</code></li>
<li>接口不能含有实例域，在Java SE 8之前也不能在接口中实现方法</li>
<li>为了让类实现一个接口，需要<ol>
<li>使用关键字<code>implement</code>将类声明为实现给定的接口</li>
<li>对接口中的所有方法进行定义</li>
<li>在实现接口时，必须把所有方法都设置成<code>public</code></li>
<li>实现抽象方法时必须使用完全相同的方法头</li>
</ol>
</li>
</ul>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p><code>Arrays</code>类中的<code>sort</code>方法承诺可以对对象数组进行排序，但要求满足下列前提： 对象所属的类必须实现了<code>Comparable</code>接口</p>
<p>下面是Java SE 5。0中已经改进为泛型类型的<code>Comparable</code>接口代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    int compareTo(T other);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int compareTo(Employee other) // 不带类型参数的话就默认调用Object类型参数</span><br></pre></td></tr></table></figure>

<p>说明，任何实现<code>Comparable</code>接口的类都需要包含<code>compareTo</code>方法并且这个方法的参数必须是一个<code>Object</code>对象，最终返回一个整形数值</p>
<p>这里我们在<code>Employee</code>类中提供一个<code>compareTo</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Employee implements Comparable&lt;Employee&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public int compareTo(Employee otherObject)</span><br><span class="line">    &#123;</span><br><span class="line">        return Double.compare(salary, other.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：为什么不直接在<code>Employee</code>类中提供<code>compareTo</code>方法而必须要实现<code>Comparable</code>接口？</p>
<p>解答：Java是一种强类型(strongly typed)语言，在调用方法的时候编译器会检查方法是否存在。在<code>sort</code>方法中可能存在下列语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (a[i].compareTo(a[j]) &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">    //rearrange a[i] and a[j]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为此，编译器必须确认a[i]一定有<code>CompareTo</code>方法，如果a是一个<code>Comparable</code>对象的数组，就可以确保有<code>compareTo</code>方法。如果a[i]不属于实现了<code>Comparable</code>接口的类，那么虚拟机将抛出异常</p>
<h3 id="6-1-2-接口的特性"><a href="#6-1-2-接口的特性" class="headerlink" title="6.1.2 接口的特性"></a>6.1.2 接口的特性</h3><ol>
<li>接口不是类，不能用<code>new</code>运算符来实例化一个接口</li>
<li>尽管不能构造接口的对象，却能声明接口的变量</li>
<li>接口变量必须引用实现了接口的对象</li>
<li>可以使用<code>instanceof</code>检查一个对象是否实现了某个特定的接口</li>
<li>接口中的域将被自动设置为<code>public static final</code>。出于习惯或提高清晰度也可以加上，但不建议这么做</li>
</ol>
<p>C++注释：</p>
<ol>
<li>C++允许一个类有多个超类，这种特性称为多重继承(multiple inheritance)，而Java不支持多重继承的主要原因是多重继承会让语言本身变得非常复杂，效率也会降低</li>
<li>C++的多重继承伴随而来许多复杂特性，因此C++程序员也很少使用多重继承</li>
</ol>
<h3 id="6-1-3-静态方法"><a href="#6-1-3-静态方法" class="headerlink" title="6.1.3 静态方法"></a>6.1.3 静态方法</h3><p>在Java SE 8中，允许在接口中增加静态方法，虽然这样有违于将接口作为规范的初衷。到目前为止，通常的做法都是将静态方法放在伴随类中。在标准库中可以看到成对出现的接口和实用工具类，如<code>Collection/Collections</code>或<code>Path/Paths</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在Java SE 8中为Path接口增加以下方法</span><br><span class="line"></span><br><span class="line">public interface Path</span><br><span class="line">&#123;</span><br><span class="line">    public static Path get(String first, String... more)</span><br><span class="line">    return FileSystem.getDefault().getPath(first, more);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就不需要Paths类了。在实现自己的接口是，不在需要为实用工具方法另外提供一个伴随类</p>
<h3 id="6-1-4-默认方法"><a href="#6-1-4-默认方法" class="headerlink" title="6.1.4 默认方法"></a>6.1.4 默认方法</h3><p>可以为接口方法提供一个默认实现，必须用<code>default</code>修饰符标记这样一个方法。在一些情况下默认方法很有用，如希望在发生鼠标点击事件时获得通知，就需要实现一个包含5个方法的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public interface MouseListener</span><br><span class="line">&#123;</span><br><span class="line">    default void mouseClicked(MouseEvent event) &#123;&#125;;</span><br><span class="line">    default void mousePressed(MouseEvent event) &#123;&#125;;</span><br><span class="line">    default void mouseReleased(MouseEvent event) &#123;&#125;;</span><br><span class="line">    default void mouseEntered(MouseEvent event) &#123;&#125;;</span><br><span class="line">    default void mouseExited(MouseEvent event) &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\* 大多数情况下，只需要关注1或2个事件类型。</span><br><span class="line"> * 可以把所有方法都声明为默认方法，默认方法什么都不做</span><br><span class="line"> * 这样就不再需要相应的伴随类来实现相应方法 </span><br><span class="line"> *\</span><br><span class="line"></span><br><span class="line">class test implements MouseListener</span><br><span class="line">&#123;</span><br><span class="line">    void mouseCliked(MouseEvent event)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认方法的一个重要用法是”接口演化”(interface evolution)。</p>
<p>假设我们提供了一个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Bag implement Colletion</span><br></pre></td></tr></table></figure>

<p>然后在Java SE 8中增加了一个<code>stream</code>方法，如果<code>stream</code>方法不是默认方法，那么<code>Bag</code>类将无法编译，因为它没有实现这个新方法。也就是说，为接口添加一个非默认方法不能保证”源代码兼容”(source compatible)</p>
<p>假设不重新编译这个类，而是使用原先一个包含这个类的JAR文件，那么这个类能正常加载，尽管没有新方法。但是在一个<code>Bag</code>类实例上调用<code>stream</code>方法就会报错</p>
<p>使用默认方法可以解决以上的两个问题</p>
<h3 id="6-1-5-解决默认方法冲突"><a href="#6-1-5-解决默认方法冲突" class="headerlink" title="6.1.5 解决默认方法冲突"></a>6.1.5 解决默认方法冲突</h3><p>如果在接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样方法。Java将使用一下规则来解决冲突：</p>
<ol>
<li>超类优先：如果超类提供了一个具体方法，同名并且有相同参数类型的默认方法会被忽略</li>
<li>接口冲突：如果一个超接口提供了一个默认方法，另一个接口提供了一个同名并且有相同参数类型的方法，必须用覆盖这个方法来解决冲突</li>
</ol>
<h4 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">interface Named</span><br><span class="line">&#123;</span><br><span class="line">    default String getName() &#123;</span><br><span class="line">        return getClass().getName() + &quot;_&quot; + hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Person</span><br><span class="line">&#123;</span><br><span class="line">    String name=&quot;Teacher&quot;;</span><br><span class="line">    default String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Teacher implements Named, Person</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Teacher(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;return Person.super.getName();&#125; // 选择两个冲突方法中的一个</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果Named接口中没有提供默认方法，Teacher类不会继承Person接口的默认方法，需要自己重新实现</span><br><span class="line">// 如果两个接口都没有提供默认方法，那么类可以实现这个方法，也可以作为抽象类不实现。这与Java SE 8之前情况一样</span><br></pre></td></tr></table></figure>

<p>警告： 由于”类优先”的规则，我们不能让一个默认方法重新定义<code>Object</code>类中的某个方法</p>
<h2 id="6-2-lambda-表达式"><a href="#6-2-lambda-表达式" class="headerlink" title="6.2 lambda 表达式"></a>6.2 lambda 表达式</h2><ul>
<li>lambda表达式是一个可传递的代码块，可以在以后执行一次或多次</li>
<li>到目前为止，在Java中传递代码段并不容易。Java是一种面向对象语言，所以必须先构造一个对象，这个对象的类需要有一个方法能包含所需的代码</li>
</ul>
<h3 id="6-2-1-lambda-表达式的语法"><a href="#6-2-1-lambda-表达式的语法" class="headerlink" title="6.2.1 lambda 表达式的语法"></a>6.2.1 lambda 表达式的语法</h3><p>一种lambda表达式形式：参数，箭头(-&gt;)以及一个表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;String&gt; comp = (first, second)</span><br><span class="line">        -&gt; first.length() - second.length(); </span><br><span class="line">// 可以推导出一个lambda表达式的参数类型就可以忽略其类型</span><br><span class="line">// 无需制定lambda表达式的返回类型，lambda表达式的返回类型总是由上下文推导出来的</span><br><span class="line"></span><br><span class="line">(String first, String second) -&gt;</span><br><span class="line">&#123;</span><br><span class="line">    if (first.length() &lt; second.length()) return -1;</span><br><span class="line">    else if (first.length() &gt; second.length()) return 1;</span><br><span class="line">    else return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">() -&gt; &#123;for (int i = 100; i &gt;= 0; i--) System.out.println(i);&#125;; // 没有参数时仍要提供空括号</span><br><span class="line"></span><br><span class="line">ActionListener listener = event -&gt;</span><br><span class="line">    System.out.println(&quot;The time is &quot; + new Date()); // 只有一个参数的时候，可以推导出参数类型，甚至可以省略小括号</span><br></pre></td></tr></table></figure>

<h3 id="6-2-2-函数式接口"><a href="#6-2-2-函数式接口" class="headerlink" title="6.2.2 函数式接口"></a>6.2.2 函数式接口</h3><p>在Java中有许多封装代码块的接口，如<code>ActionListener</code>或<code>Comparator</code>，lambda表达式与这些接口是兼容的。对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口称为函数式接口(functional interface)</p>
<p>lambda表达式可以转换为接口。下面来看一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Timer t = new Timer(1000, event -&gt;</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(&quot;At the tone, the time is &quot; + new Date());</span><br><span class="line">    Toolkit.getDefaultToolkit().beep();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在Java中，lambda表达式只能转换为函数式接口</p>
<h3 id="6-2-3-方法引用-method-reference"><a href="#6-2-3-方法引用-method-reference" class="headerlink" title="6.2.3 方法引用(method reference)"></a>6.2.3 方法引用(method reference)</h3><p>有时候可能已经存在现有的方法来完成你想要传递到其他代码的某个动作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Timer t = new Timer(1000, event -&gt; System.out.println(event));</span><br><span class="line">// 等价于</span><br><span class="line">Timer t = new Timer(1000, System::println)</span><br><span class="line"></span><br><span class="line">// 不考虑字母大小写而对字符串排序</span><br><span class="line">Arrays.sort(string, String::compareToIgnoreCase)</span><br><span class="line"></span><br><span class="line">// 我们用::操作符分割方法名与对象或类名，主要有三种情况</span><br><span class="line"></span><br><span class="line">Object::instanceMethod</span><br><span class="line">Class::staticMethod</span><br><span class="line">Class::instanceMethod</span><br></pre></td></tr></table></figure>

<p>如果有多个同名的重载方法，编译器会尝试从上下文找出你指的那一个方法。类似于lambda表达式，方法引用不能独立存在，总是会转换成函数式接口的实例</p>
<h3 id="6-2-4-构造器引用"><a href="#6-2-4-构造器引用" class="headerlink" title="6.2.4 构造器引用"></a>6.2.4 构造器引用</h3><ul>
<li>构造器引用和方法引用类似，只不过方法名为new。</li>
<li>选择哪个构造器取决于上下文</li>
</ul>
<p>(涉及到泛型程序设计的问题，暂且跳过)</p>
<h3 id="6-2-5-变量作用域"><a href="#6-2-5-变量作用域" class="headerlink" title="6.2.5 变量作用域"></a>6.2.5 变量作用域</h3><p>lambda表达式有三个部分：</p>
<ol>
<li>一个代码块</li>
<li>参数</li>
<li>自由变量的值，这里指非参数并且不在代码中定义的变量</li>
</ol>
<p>关于代码块以及自由变量有一个术语：闭包(closure)。在Java中，lambda表达式就是闭包</p>
<ul>
<li>lambda表达式可以捕获外围作用域中变量的值。但要确保所捕获的值是明确定义的，这里有一个重要的限制，就是只能引用值不改变的变量。</li>
<li>如果在lambda表达式中改变变量，并发执行多个动作是不安全的。</li>
<li>如果引用的变量可能在外部改变，那么这样的引用也是不合法的</li>
<li>lambda表达式中捕获的变量必须是<strong>实际上的最终变量</strong>(effectively final)，实际上的最终变量是值，这个变量初始化之后就不会再为它赋新值。</li>
<li>lambda表达式的外部和内部有相同的作用域时，同样使用命名冲突和遮蔽的相关规则，因此lambda表达式中声明与一个局部变量同名的参数或局部变量是不合法的。</li>
<li>在方法中不能有两个同名的局部变量，同样在lambda表达式中也不能有同名的局部变量</li>
<li>在lambda表达式中使用<code>this</code>关键字，是指创建这个lambda表达式的方法的this参数，如下例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Appication</span><br><span class="line">&#123;</span><br><span class="line">    public void init()</span><br><span class="line">    &#123;</span><br><span class="line">        ActionListener listener = event -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(this.toString());</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在lambda表达式中，<code>this</code>的使用没有任何特殊之处，无论是在lambda表达式中，还是在<code>init()</code>方法的其他位置，含义都没有改变，始终调用<code>Application</code>对象的<code>toString</code>方法</p>
<h3 id="6-2-6-处理lambda-表达式"><a href="#6-2-6-处理lambda-表达式" class="headerlink" title="6.2.6 处理lambda 表达式"></a>6.2.6 处理lambda 表达式</h3><p>使用lambda表达式的重点是延迟执行(deferred execution)，希望延迟执行代码有很多原因：</p>
<ul>
<li>在一个单独的线程中运行代码；</li>
<li>多次运行代码；</li>
<li>在算法的恰当位置运行代码；</li>
<li>发生某种情况时运行代码；</li>
<li>只在必要的时候才运行代码；</li>
<li>大多数标准函数式接口都提供了非抽象方法来生成或合并函数。例如<code>Predicate.isEqual(a)</code>等同于<code>a::equals</code>,不过a为<code>null</code>时也能工作</li>
<li>已经提供了默认的方法<code>and、or和negate</code>来合并谓词，如<code>Predicate.isEqual(a)or(Predicate.isEquals(b))</code>等同于<code>x -&gt; a.euqals(x) || b.equals(x)</code></li>
<li>如果设计你自己的接口，其中只有一个抽象方法，可以用<code>@FunctionInterface</code>注解来标记这个接口，这样做有两个优点：<ol>
<li>如果你无意增加了另一个非抽象方法，编译器会产生一个错误讯息</li>
<li>另外javadoc页里会指出你的接口是一个函数式接口</li>
</ol>
</li>
<li>并不是必须使用注解。根据定义，任何只有一个抽象方法的接口都是函数式接口</li>
</ul>
<h2 id="6-3-内部类"><a href="#6-3-内部类" class="headerlink" title="6.3 内部类"></a>6.3 内部类</h2><p>内部类(inner class)是定义在另一个类中类。</p>
<p>使用内部类主要原因有以下三点：</p>
<ol>
<li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据</li>
<li>内部类可以对同一个包的其他类隐藏起来</li>
<li>当想要定义一个回调函数且不想编写大量代码时，使用匿名(anonymous)内部类比便捷</li>
</ol>
<p>C++注释：</p>
<ul>
<li>C++有嵌套类。一个嵌套的类包含在外围类的作用域内。</li>
<li>嵌套类有两个好处：命名控制和访问控制<ul>
<li>命名控制避免了与其他同名的类发生冲突，但这个问题在Java中并不重要，因为Java已经提供了有效的命名控制</li>
<li>访问控制：嵌套类只会对其他代码都是不可见的，即使设计成公有的，它的数据域也只能被被嵌套类所控制而不会暴露给其他代码。在Java中只有内部类能够实现这样的控制</li>
</ul>
</li>
<li>Java内部类有一个隐式引用，可以引用实例化后该内部对象的外围类对象。通过这个指针可以访问外围类对象的全部装的</li>
<li>Java中<code>static</code>内部类没有这种附加指针，这样的内部类与C++的嵌套类很相似</li>
</ul>
<h3 id="6-3-1-使用内部类访问对象状态"><a href="#6-3-1-使用内部类访问对象状态" class="headerlink" title="6.3.1 使用内部类访问对象状态"></a>6.3.1 使用内部类访问对象状态</h3><ul>
<li>内部类既可以访问自身的数据域，还可以访问创建它的外围类对象的数据域。</li>
<li>内部类的对象总有一个隐式引用指向了创建它的外部类对象，这个引用称为<code>outer</code></li>
<li>注意<code>outer</code>并不是关键字，这里仅仅用来说明内部类的机制</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package innerClass;</span><br><span class="line"></span><br><span class="line">import java.awt.*;</span><br><span class="line">import java.util.*;</span><br><span class="line">import java.awt.event.*;</span><br><span class="line">import javax.swing.*;</span><br><span class="line">import javax.swing.Timer;</span><br><span class="line"></span><br><span class="line">public class innerClassTest &#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        TalkingClock clock = new TalkingClock(1000, true);</span><br><span class="line">        clock.start();</span><br><span class="line"></span><br><span class="line">        JOptionPane.showConfirmDialog(null, &quot;Quit program?&quot;);</span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TalkingClock</span><br><span class="line">&#123;</span><br><span class="line">    private int interval;</span><br><span class="line">    private boolean beep;</span><br><span class="line"></span><br><span class="line">    public TalkingClock(int interval, boolean beep)</span><br><span class="line">    &#123;</span><br><span class="line">        this.interval = interval;</span><br><span class="line">        this.beep = beep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start()</span><br><span class="line">    &#123;</span><br><span class="line">        ActionListener listener = new TimePrinter();</span><br><span class="line">        Timer t = new Timer(interval, listener);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class TimePrinter implements ActionListener // 内部类</span><br><span class="line">    &#123;</span><br><span class="line">        public void actionPerformed(ActionEvent event)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;At the tone, the time is &quot; + new Date());</span><br><span class="line">            if (beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-2-内部类的特殊语法规则"><a href="#6-3-2-内部类的特殊语法规则" class="headerlink" title="6.3.2 内部类的特殊语法规则"></a>6.3.2 内部类的特殊语法规则</h3><p>使用外围类引用的正规语法：<code>OuterClass.this</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void actionPerformed(ActionEvent event)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(&quot;At the tone, the time is &quot; + new Date());</span><br><span class="line">    if (TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反过来，可以采用下列语法更加明确地编写内部对象的构造器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">outerObject.new InnerClass(construction parameters)</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line"></span><br><span class="line">ActionListener listener = this.new TimePrinter();</span><br><span class="line"></span><br><span class="line">//通常this限定词是多余的，不过可以通过显式地命名将外围类引用设置为其他的对象</span><br><span class="line"></span><br><span class="line">TalkingClock jabberer = new TalkingClock(1000, true);</span><br><span class="line">TalkingClock.TimePrinter listener = jabberer.new TimePrinter();</span><br><span class="line"></span><br><span class="line">// 注意，在外围类的作用域之外，可以这样引用内部类： OuterClass.InnerClass</span><br></pre></td></tr></table></figure>

<ul>
<li>内部类中声明的所有静态域都必须是<code>final</code>，因为我们希望一个静态域只有一个实例，不过对于每个外部对象，会分别有一个单独的内部类实例。如果这个域不是<code>final</code>的话就不唯一了</li>
<li>内部类不能有<code>static</code>方法。</li>
</ul>
<h3 id="6-3-3-局部内部类"><a href="#6-3-3-局部内部类" class="headerlink" title="6.3.3 局部内部类"></a>6.3.3 局部内部类</h3><p>如果一个类只在相应方法中创建这个类型的对象时使用一次，可以在这个方法中定义局部类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void start()</span><br><span class="line">&#123;</span><br><span class="line">    class TimePrinter implements ActionListener</span><br><span class="line">    &#123;</span><br><span class="line">        public void actionPerformed(ActionEvent event)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;At the tone, the time is&quot; + new Date());</span><br><span class="line">            if (TalkingClock.this.beep) Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ActionListener listener = new TimePrinter();</span><br><span class="line">    Timer t = new Timer(interval, listener);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>局部类不能用<code>public</code>或<code>private</code>访问说明符来进行声明，它的作用域被限定在这个局部类的块中</li>
<li>局部类的优势在于对外部世界完全地隐藏起来，即使<code>TalkingClock</code>类的其他代码也无法访问它。除了<code>start</code>方法没有任何方法能够访问它</li>
</ul>
<h3 id="6-3-4-由外部方法访问变量"><a href="#6-3-4-由外部方法访问变量" class="headerlink" title="6.3.4 由外部方法访问变量"></a>6.3.4 由外部方法访问变量</h3><ul>
<li>与其他内部类相比，局部类还有一个优点。它们不仅能够访问包含它们的外部类，还能访问局部变量，不过哪些局部变量必须事实上为<code>final</code></li>
<li>当<code>final</code>限制造成不方便的时候，我们可以把局部变量设置成一个长度为1的数组，可以相当于调用了一个可变对象</li>
</ul>
<h3 id="6-3-5-匿名内部类"><a href="#6-3-5-匿名内部类" class="headerlink" title="6.3.5 匿名内部类"></a>6.3.5 匿名内部类</h3><p>如果只创建这个类的一个对象，就不必命名了。这样的类被称为匿名内部类(anonymous inner class)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void start()</span><br><span class="line">&#123;</span><br><span class="line">    ActionListener listener = new ActionListener() &#123;</span><br><span class="line">        public void actionPerformed(ActionEvent event) &#123;</span><br><span class="line">            System.out.println(&quot;At the tone， the time is &quot; + new Date());</span><br><span class="line">            Toolkit.getDefaultToolkit().beep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Timer t = new Timer(interval, listener);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通常的语法格式为：</span><br><span class="line"></span><br><span class="line">new SuperType(construction parameters)</span><br><span class="line">&#123;</span><br><span class="line">    inner.class methods and data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当然现在使用内部类的方法不如lambda表达式来的简洁</span><br><span class="line"></span><br><span class="line">public void start()</span><br><span class="line">&#123;</span><br><span class="line">    Timer t = new Timer(interval, event -&gt; </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;At the tone, the time is &quot; + new Date);</span><br><span class="line">        if (beep) Toolkit.getDefaultToolkit().deep();</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-6-静态内部类"><a href="#6-3-6-静态内部类" class="headerlink" title="6.3.6 静态内部类"></a>6.3.6 静态内部类</h3><p>有时候使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此可以将内部类声明为<code>static</code>，以便取消产生的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] d = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            d[i] = <span class="number">100</span> * Math.random();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayAlg.Pair p = ArrayAlg.minmax(d);</span><br><span class="line">        System.out.println(<span class="string">"min = "</span> + p.getFirst());</span><br><span class="line">        System.out.println(<span class="string">"max = "</span> + p.getSecond());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> first;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> second;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">double</span> first, <span class="keyword">double</span> second)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.first = first;</span><br><span class="line">            <span class="keyword">this</span>.second = second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> second;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair <span class="title">minmax</span><span class="params">(<span class="keyword">double</span>[] value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> min = Double.POSITIVE_INFINITY;</span><br><span class="line">        <span class="keyword">double</span> max = Double.NEGATIVE_INFINITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> e: value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; e) min = e;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; e) max = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair(min, max);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/08/Java-Course/" rel="next" title="Java 程序设计基础课程笔记 by 倾启君">
                <i class="fa fa-chevron-left"></i> Java 程序设计基础课程笔记 by 倾启君
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/19/Java-PracticeIt/" rel="prev" title="Java PracticeIt">
                Java PracticeIt <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">chenshuo</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章-Java语言概述"><span class="nav-number">1.</span> <span class="nav-text">第一章 Java语言概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Java语言的特点"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 Java语言的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-简单性"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1 简单性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-面向对象"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2 面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-分布式"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.1.3 分布式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-4-可靠性"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.1.4 可靠性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-5-安全性"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.1.5 安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-6-编译与解释并存"><span class="nav-number">1.1.6.</span> <span class="nav-text">1.1.6 编译与解释并存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-7-平台无关性"><span class="nav-number">1.1.7.</span> <span class="nav-text">1.1.7 平台无关性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-8-多线程"><span class="nav-number">1.1.8.</span> <span class="nav-text">1.1.8 多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-9-支持网络编程"><span class="nav-number">1.1.9.</span> <span class="nav-text">1.1.9 支持网络编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Java技术简介"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 Java技术简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Java虚拟机"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 Java虚拟机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-Java程序种类和结构"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 Java程序种类和结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-两种程序类型-Application-应用程序-和Applet-小程序-。"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1 两种程序类型:Application(应用程序)和Applet(小程序)。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-Java程序结构"><span class="nav-number">1.4.2.</span> <span class="nav-text">1.4.2 Java程序结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章-Java语言开发环境"><span class="nav-number">2.</span> <span class="nav-text">第二章 Java语言开发环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Java开发工具"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 Java开发工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-JDK的下载与安装"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 JDK的下载与安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows"><span class="nav-number">2.1.2.</span> <span class="nav-text">Windows</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux"><span class="nav-number">2.1.3.</span> <span class="nav-text">Linux</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-安装库源文件和文档"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.2 安装库源文件和文档</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-JDK的使用"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 JDK的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-使用命令行工具编译和运行代码"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 使用命令行工具编译和运行代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-使用集成开发环境"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 使用集成开发环境</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章-Java的基本程序设计结构"><span class="nav-number">3.</span> <span class="nav-text">第三章 Java的基本程序设计结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-一个简单的Java应用程序"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 一个简单的Java应用程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-注释"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-数据类型"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-整型"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 整型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-浮点型"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2 浮点型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-boolean类型"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3 boolean类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-char类型"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.3.4 char类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-关键字和标识符"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 关键字和标识符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-关键字"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.4.1 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-标识符"><span class="nav-number">3.4.2.</span> <span class="nav-text">3.4.2 标识符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-变量和常量"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 变量和常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-变量"><span class="nav-number">3.5.1.</span> <span class="nav-text">3.5.1 变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-常量"><span class="nav-number">3.5.2.</span> <span class="nav-text">3.5.2 常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-数字类型转换"><span class="nav-number">3.6.</span> <span class="nav-text">3.6 数字类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1-数值型不同类型数据的转换"><span class="nav-number">3.6.1.</span> <span class="nav-text">3.6.1 数值型不同类型数据的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-1-隐含类型转换"><span class="nav-number">3.6.1.1.</span> <span class="nav-text">3.6.1.1 隐含类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-2-强制类型转换"><span class="nav-number">3.6.1.2.</span> <span class="nav-text">3.6.1.2 强制类型转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-字符串型数据与整型数据相互转换"><span class="nav-number">3.6.2.</span> <span class="nav-text">3.6.2 字符串型数据与整型数据相互转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-运算符"><span class="nav-number">3.7.</span> <span class="nav-text">3.7 运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-1-算术运算符"><span class="nav-number">3.7.1.</span> <span class="nav-text">3.7.1 算术运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-1-1-二元算术运算符"><span class="nav-number">3.7.1.1.</span> <span class="nav-text">3.7.1.1 二元算术运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-1-2-一元算术运算符"><span class="nav-number">3.7.1.2.</span> <span class="nav-text">3.7.1.2 一元算术运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-2-关系和boolean运算符"><span class="nav-number">3.7.2.</span> <span class="nav-text">3.7.2 关系和boolean运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-3-位运算符"><span class="nav-number">3.7.3.</span> <span class="nav-text">3.7.3 位运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-4-赋值运算符"><span class="nav-number">3.7.4.</span> <span class="nav-text">3.7.4 赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-5-运算符优先级"><span class="nav-number">3.7.5.</span> <span class="nav-text">3.7.5 运算符优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-枚举类型"><span class="nav-number">3.8.</span> <span class="nav-text">3.8 枚举类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-9-字符串"><span class="nav-number">3.9.</span> <span class="nav-text">3.9 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-1-创建字符串的三种格式"><span class="nav-number">3.9.1.</span> <span class="nav-text">3.9.1 创建字符串的三种格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-2-字符串的几种常用方法"><span class="nav-number">3.9.2.</span> <span class="nav-text">3.9.2 字符串的几种常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-3-空串和null串"><span class="nav-number">3.9.3.</span> <span class="nav-text">3.9.3 空串和null串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-10-输入输出"><span class="nav-number">3.10.</span> <span class="nav-text">3.10 输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-10-1-读取输入"><span class="nav-number">3.10.1.</span> <span class="nav-text">3.10.1 读取输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-10-2-格式化输出"><span class="nav-number">3.10.2.</span> <span class="nav-text">3.10.2 格式化输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-10-3-文件输入与输出"><span class="nav-number">3.10.3.</span> <span class="nav-text">3.10.3 文件输入与输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-11-控制流程"><span class="nav-number">3.11.</span> <span class="nav-text">3.11 控制流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-12-大数值"><span class="nav-number">3.12.</span> <span class="nav-text">3.12 大数值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-13-数组"><span class="nav-number">3.13.</span> <span class="nav-text">3.13 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-13-1-基本概念"><span class="nav-number">3.13.1.</span> <span class="nav-text">3.13.1 基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-12-2-内存分配"><span class="nav-number">3.13.2.</span> <span class="nav-text">3.12.2 内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-12-3-一维数组"><span class="nav-number">3.13.3.</span> <span class="nav-text">3.12.3 一维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-12-4-foreach-语句"><span class="nav-number">3.13.4.</span> <span class="nav-text">3.12.4 foreach 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-12-5-多维数组"><span class="nav-number">3.13.5.</span> <span class="nav-text">3.12.5 多维数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四章-对象和类-课本"><span class="nav-number">4.</span> <span class="nav-text">第四章 对象和类(课本)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-类的基本概念"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 类的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-定义类"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 定义类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-类的一般结构"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1 类的一般结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#四种类修饰符的含义"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">四种类修饰符的含义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-成员变量"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2 成员变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-1-成员变量修饰符的含义"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">4.2.2.1 成员变量修饰符的含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-2-成员变量与局部变量的区别"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">4.2.2.2 成员变量与局部变量的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-成员方法"><span class="nav-number">4.2.3.</span> <span class="nav-text">4.2.3 成员方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-对象的创建和使用"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 对象的创建和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-创建对象"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1 创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-对象的使用"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2 对象的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-参数的传递"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 参数的传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-以变量为参数调用方法"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.4.1 以变量为参数调用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-以数组作为参数或返回值的方法调用"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.4.2 以数组作为参数或返回值的方法调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-匿名对象"><span class="nav-number">4.5.</span> <span class="nav-text">4.5 匿名对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-类的私有成员和公共成员"><span class="nav-number">4.6.</span> <span class="nav-text">4.6 类的私有成员和公共成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-1-私有成员"><span class="nav-number">4.6.1.</span> <span class="nav-text">4.6.1 私有成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-2-公共成员"><span class="nav-number">4.6.2.</span> <span class="nav-text">4.6.2 公共成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-方法的重载"><span class="nav-number">4.7.</span> <span class="nav-text">4.7 方法的重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-8-构造方法"><span class="nav-number">4.8.</span> <span class="nav-text">4.8 构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-1-构造方法的定义和作用"><span class="nav-number">4.8.1.</span> <span class="nav-text">4.8.1 构造方法的定义和作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-9-静态成员"><span class="nav-number">4.9.</span> <span class="nav-text">4.9 静态成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-1-实例成员"><span class="nav-number">4.9.1.</span> <span class="nav-text">4.9.1 实例成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-2-静态变量"><span class="nav-number">4.9.2.</span> <span class="nav-text">4.9.2 静态变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-3-静态方法"><span class="nav-number">4.9.3.</span> <span class="nav-text">4.9.3 静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-9-4-静态初始化器"><span class="nav-number">4.9.4.</span> <span class="nav-text">4.9.4 静态初始化器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-对象的应用"><span class="nav-number">4.9.5.</span> <span class="nav-text">4.10 对象的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-10-1-对象的赋值与比较"><span class="nav-number">4.9.5.1.</span> <span class="nav-text">4.10.1 对象的赋值与比较</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-2-引用变量作为方法的返回值"><span class="nav-number">4.9.6.</span> <span class="nav-text">4.10.2 引用变量作为方法的返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-3-类类型的数组"><span class="nav-number">4.9.7.</span> <span class="nav-text">4.10.3 类类型的数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-10-4-以对象数组为参数进行方法调用"><span class="nav-number">4.9.8.</span> <span class="nav-text">4.10.4 以对象数组为参数进行方法调用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用的包和类"><span class="nav-number">5.</span> <span class="nav-text">常用的包和类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Java语言中的常用包"><span class="nav-number">5.1.</span> <span class="nav-text">1.Java语言中的常用包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-语言包"><span class="nav-number">5.1.1.</span> <span class="nav-text">1.1 语言包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-输入输出流的文件包"><span class="nav-number">5.1.2.</span> <span class="nav-text">1.2 输入输出流的文件包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-抽象窗口工具包"><span class="nav-number">5.1.3.</span> <span class="nav-text">1.3 抽象窗口工具包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-轻型组件工具包"><span class="nav-number">5.1.4.</span> <span class="nav-text">1.4 轻型组件工具包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-使用包"><span class="nav-number">5.1.5.</span> <span class="nav-text">1.5 使用包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-小程序包"><span class="nav-number">5.1.6.</span> <span class="nav-text">1.6 小程序包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-网络功能包"><span class="nav-number">5.1.7.</span> <span class="nav-text">1.7 网络功能包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-数据库连接包"><span class="nav-number">5.1.8.</span> <span class="nav-text">1.8 数据库连接包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-文本包"><span class="nav-number">5.1.9.</span> <span class="nav-text">1.9 文本包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Java语言中的常用类"><span class="nav-number">5.2.</span> <span class="nav-text">2.Java语言中的常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Date-类"><span class="nav-number">5.2.1.</span> <span class="nav-text">2.1 Date 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-Calendar类"><span class="nav-number">5.2.2.</span> <span class="nav-text">2.2 Calendar类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-Random类"><span class="nav-number">5.2.3.</span> <span class="nav-text">2.3 Random类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-Math类"><span class="nav-number">5.2.4.</span> <span class="nav-text">2.4 Math类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章-继承"><span class="nav-number">6.</span> <span class="nav-text">第五章 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-类、超类、子类"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 类、超类、子类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-定义子类"><span class="nav-number">6.1.1.</span> <span class="nav-text">5.1.1 定义子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-覆盖方法"><span class="nav-number">6.1.2.</span> <span class="nav-text">5.1.2 覆盖方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-子类构造器"><span class="nav-number">6.1.3.</span> <span class="nav-text">5.1.3 子类构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-4-多态"><span class="nav-number">6.1.4.</span> <span class="nav-text">5.1.4 多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-5-理解方法调用"><span class="nav-number">6.1.5.</span> <span class="nav-text">5.1.5 理解方法调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-6-阻止继承：final类和方法"><span class="nav-number">6.1.6.</span> <span class="nav-text">5.1.6 阻止继承：final类和方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-7-强制类型转换"><span class="nav-number">6.1.7.</span> <span class="nav-text">5.1.7 强制类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-8-抽象类"><span class="nav-number">6.1.8.</span> <span class="nav-text">5.1.8 抽象类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-Object：所有类的超类"><span class="nav-number">6.2.</span> <span class="nav-text">5.2 Object：所有类的超类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-equals-方法"><span class="nav-number">6.2.1.</span> <span class="nav-text">5.2.1 equals 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-相等测试与继承"><span class="nav-number">6.2.2.</span> <span class="nav-text">5.2.2 相等测试与继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-hashCode-方法"><span class="nav-number">6.2.3.</span> <span class="nav-text">5.2.3 hashCode　方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-4-toString-方法"><span class="nav-number">6.2.4.</span> <span class="nav-text">5.2.4 toString 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-泛型数组列表"><span class="nav-number">6.3.</span> <span class="nav-text">5.3 泛型数组列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-访问数组列表元素"><span class="nav-number">6.3.1.</span> <span class="nav-text">5.3.1 访问数组列表元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-类型化与原始数组列表的兼容性"><span class="nav-number">6.3.2.</span> <span class="nav-text">5.3.2 类型化与原始数组列表的兼容性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-对象包装器和自动装箱"><span class="nav-number">6.4.</span> <span class="nav-text">5.4 对象包装器和自动装箱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-参数数量可变的方法"><span class="nav-number">6.5.</span> <span class="nav-text">5.5 参数数量可变的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-枚举类"><span class="nav-number">6.6.</span> <span class="nav-text">5.6 枚举类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-反射"><span class="nav-number">6.7.</span> <span class="nav-text">5.7 反射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-继承的设计技巧"><span class="nav-number">6.8.</span> <span class="nav-text">5.8 继承的设计技巧</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六章-接口、lambda类与内部类"><span class="nav-number">7.</span> <span class="nav-text">第六章 接口、lambda类与内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-接口"><span class="nav-number">7.1.</span> <span class="nav-text">6.1 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-接口概念"><span class="nav-number">7.1.1.</span> <span class="nav-text">6.1.1 接口概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#案例分析"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">案例分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-接口的特性"><span class="nav-number">7.1.2.</span> <span class="nav-text">6.1.2 接口的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-3-静态方法"><span class="nav-number">7.1.3.</span> <span class="nav-text">6.1.3 静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-4-默认方法"><span class="nav-number">7.1.4.</span> <span class="nav-text">6.1.4 默认方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-5-解决默认方法冲突"><span class="nav-number">7.1.5.</span> <span class="nav-text">6.1.5 解决默认方法冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#案例分析-1"><span class="nav-number">7.1.5.1.</span> <span class="nav-text">案例分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-lambda-表达式"><span class="nav-number">7.2.</span> <span class="nav-text">6.2 lambda 表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-lambda-表达式的语法"><span class="nav-number">7.2.1.</span> <span class="nav-text">6.2.1 lambda 表达式的语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-函数式接口"><span class="nav-number">7.2.2.</span> <span class="nav-text">6.2.2 函数式接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-方法引用-method-reference"><span class="nav-number">7.2.3.</span> <span class="nav-text">6.2.3 方法引用(method reference)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4-构造器引用"><span class="nav-number">7.2.4.</span> <span class="nav-text">6.2.4 构造器引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-5-变量作用域"><span class="nav-number">7.2.5.</span> <span class="nav-text">6.2.5 变量作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-6-处理lambda-表达式"><span class="nav-number">7.2.6.</span> <span class="nav-text">6.2.6 处理lambda 表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-内部类"><span class="nav-number">7.3.</span> <span class="nav-text">6.3 内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-使用内部类访问对象状态"><span class="nav-number">7.3.1.</span> <span class="nav-text">6.3.1 使用内部类访问对象状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-内部类的特殊语法规则"><span class="nav-number">7.3.2.</span> <span class="nav-text">6.3.2 内部类的特殊语法规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-3-局部内部类"><span class="nav-number">7.3.3.</span> <span class="nav-text">6.3.3 局部内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-4-由外部方法访问变量"><span class="nav-number">7.3.4.</span> <span class="nav-text">6.3.4 由外部方法访问变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-5-匿名内部类"><span class="nav-number">7.3.5.</span> <span class="nav-text">6.3.5 匿名内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-6-静态内部类"><span class="nav-number">7.3.6.</span> <span class="nav-text">6.3.6 静态内部类</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenshuo</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
